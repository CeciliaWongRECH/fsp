<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: MCUboot Port (rm_mcuboot_port)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.4.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___r_m___m_c_u_b_o_o_t___p_o_r_t.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">MCUboot Port (rm_mcuboot_port)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>MCUboot Port for RA MCUs. </p>
<h1><a class="anchor" id="r-mcuboot-port-overview"></a>
Overview</h1>
<dl class="section note"><dt>Note</dt><dd><b>The MCUboot Port does not provide any interfaces to the user. Consult the MCUboot documentation at <a href="https://mcu-tools.github.io/mcuboot/">https://mcu-tools.github.io/mcuboot/</a> for further information.</b></dd></dl>
<h1><a class="anchor" id="r-mcuboot-port-configuration"></a>
Configuration</h1>
<p><h2>Build Time Configurations for MCUboot</h2>
The following build time configurations are defined in mcu-tools/include/mcuboot_config/mcuboot_config.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>General &gt; Custom mcuboot_config.h</td><td>Manual Entry</td><td></td><td>Add a path to your custom mcuboot_config.h file. It can be used to override some or all of the configurations defined here, and to define additional configurations. </td></tr>
<tr>
<td>General &gt; Upgrade Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Swap</li>
<li>
Overwrite Only</li>
<li>
Overwrite Only Fast</li>
</ul>
</td><td>Overwrite Only </td><td>Swap supports A/B image swapping with rollback. Other modes with simpler code path, which only supports overwriting the existing image with the update image or running the newest image directly from its flash partition, are also available. </td></tr>
<tr>
<td>General &gt; Validate Primary Image</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Enabled </td><td>Always check the signature of the image in the primary slot before booting, even if no upgrade was performed. This is recommended if the boot time penalty is acceptable. </td></tr>
<tr>
<td>General &gt; Downgrade Prevention (Overwrite Only)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Prevent downgrades by enforcing incrementing version numbers. When this option is set, any upgrade must have greater major version or greater minor version with equal major version. This mechanism only protects against some attacks against version downgrades (for example, a JTAG could be used to write an older version). </td></tr>
<tr>
<td>General &gt; Number of Images Per Application</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
1</li>
<li>
2 (TrustZone)</li>
</ul>
</td><td>1 </td><td>Number of separately updateable images. </td></tr>
<tr>
<td>General &gt; Watchdog Feed</td><td>Manual Entry</td><td></td><td>This function might be implemented if the OS / HW watchdog is enabled while doing a swap upgrade and the time it takes for a swapping is long enough to cause an unwanted reset. If implementing this, the OS main.c must also enable the watchdog (if required)! </td></tr>
<tr>
<td>General &gt; Measured Boot</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Copies the boot data into the secure RAM, intended to be used by the secure App. </td></tr>
<tr>
<td>General &gt; Data Sharing</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Copies the user data into the secure RAM, intended to be used by the secure App. </td></tr>
<tr>
<td>Signing Options &gt; TrustZone &gt; Boot Record (Image 2)</td><td>String length must be 12 characters or less.</td><td></td><td>Create CBOR encoded boot record TLV for Image 2. Represents the role of the software component (e.g. CoFM for coprocessor firmware). [max. 12 characters] </td></tr>
<tr>
<td>Signing Options &gt; TrustZone &gt; Custom (Image 2)</td><td>Manual Entry</td><td>--confirm </td><td>Add any custom options to pass to imgtool.py here. --pad places a trailer on the image that indicates that the image should be considered an upgrade. Writing this image in the secondary slot will then cause the bootloader to upgrade to it. --confirm marks the image as confirmed, which causes the upgrade to be permanent. </td></tr>
<tr>
<td>Signing Options &gt; Signature Type</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
None</li>
<li>
ECDSA P-256</li>
<li>
RSA 2048</li>
<li>
RSA 3072</li>
</ul>
</td><td>ECDSA P-256 </td><td>Configure the signature type. </td></tr>
<tr>
<td>Signing Options &gt; Boot Record</td><td>String length must be 12 characters or less.</td><td></td><td>Create CBOR encoded boot record TLV. Represents the role of the software component (e.g. CoFM for coprocessor firmware). [max. 12 characters] </td></tr>
<tr>
<td>Signing Options &gt; Custom</td><td>Manual Entry</td><td>--confirm </td><td>Add any custom options to pass to imgtool.py here. --pad places a trailer on the image that indicates that the image should be considered an upgrade. Writing this image in the secondary slot will then cause the bootloader to upgrade to it. --confirm marks the image as confirmed, which causes the upgrade to be permanent. </td></tr>
<tr>
<td>Signing Options &gt; Python</td><td>Manual Entry</td><td>python </td><td>Name of the python command to use. Default is python, but can be updated to python3 for Linux or an absolute path if needed. </td></tr>
<tr>
<td>Debugging &gt; Log Level</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Off</li>
<li>
Error</li>
<li>
Warning</li>
<li>
Info</li>
<li>
Debug</li>
</ul>
</td><td>Off </td><td>Configure log level. </td></tr>
<tr>
<td>Flash Layout &gt; TrustZone &gt; Non-Secure Callable Region Size (Bytes)</td><td>Value must be an integer multiple of the 1024.</td><td>0x0 </td><td>Size of the Non-Secure Callable region of the Secure image. </td></tr>
<tr>
<td>Flash Layout &gt; TrustZone &gt; Non-Secure Flash Area Size (Bytes) (TrustZone Non-Secure)</td><td>Value must be an integer multiple of the largest erase size on the mcu.</td><td>0x0 </td><td>Size of the Non-Secure region. This must be non-zero for all TrustZone projects to ensure memory is partitioned correctly, even if the Secure and Non-Secure regions are treated as a single image. If the Non-Secure region can be updated separately, this size must account for the header and trailer. </td></tr>
<tr>
<td>Flash Layout &gt; TrustZone &gt; Non-Secure Callable RAM Region Size (Bytes)</td><td>Value must be an integer multiple of the 1024.</td><td>0x0 </td><td>Size of the Non-Secure Callable RAM region of the Secure image. </td></tr>
<tr>
<td>Flash Layout &gt; TrustZone &gt; Non-Secure RAM Region Size (Bytes) (TrustZone Non-Secure)</td><td>Value must be an integer multiple of the 8192.</td><td>0x0 </td><td>Size of the Non-Secure RAM region. This must be non-zero for all TrustZone projects to ensure memory is partitioned correctly, even if the Secure and Non-Secure regions are treated as a single image. </td></tr>
<tr>
<td>Flash Layout &gt; TrustZone &gt; Image 2 Header Size (Bytes)</td><td>Value must be an integer multiple of 0x80 (alignment required by VTOR).</td><td>0x80 </td><td>Size of the flash reserved for the application image header for Image 2. </td></tr>
<tr>
<td>Flash Layout &gt; Bootloader Flash Area Size (Bytes)</td><td>Value must be an integer multiple of the largest erase size on the mcu.</td><td>0x20000 </td><td>Size of the flash reserved for the bootloader. </td></tr>
<tr>
<td>Flash Layout &gt; Image 1 Header Size (Bytes)</td><td>Value must be an integer multiple of 0x80 (alignment required by VTOR).</td><td>0x80 </td><td>Size of the flash reserved for the application image header. </td></tr>
<tr>
<td>Flash Layout &gt; Image 1 Flash Area Size (Bytes)</td><td>Value must be an integer multiple of the largest erase size on the mcu.</td><td>0x20000 </td><td>Size of the application image 1, including the header and trailer. For TrustZone projects, enter the combined size of the Secure and Non-Secure Callable regions if the Non-Secure image can be updated separately, or enter the size of the entire image slot if Secure, Non-Secure Callable, and Non-Secure regions are updated as a single image. </td></tr>
<tr>
<td>Flash Layout &gt; Scratch Flash Area Size (Bytes)</td><td>Value must be an integer multiple of the largest erase size on the mcu.</td><td>0x0 </td><td>Size of the scratch area. Only required for swap update method. </td></tr>
<tr>
<td>Data Sharing &gt; Maximum Measured Boot Record Size (Bytes)</td><td>Value must be an integer.</td><td>0x64 </td><td>Maximum size of the boot record. </td></tr>
<tr>
<td>Data Sharing &gt; Shared Data Size (Bytes)</td><td>Value must be an integer.</td><td>0x380 </td><td>Size of the shared RAM area. Required for Measured Boot. </td></tr>
<tr>
<td>Data Sharing &gt; Shared Data Address</td><td>Value must be an integer</td><td>0x20000000 </td><td>Shared RAM start address. Required for Measured Boot. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-mcuboot-port-clock-configuration"></a>
Clock Configuration</h2>
<p>This module does not use peripheral clocks.</p>
<h2><a class="anchor" id="r-mcuboot-port-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-mcuboot-port-usage-notes"></a>
Usage Notes</h1>
<h2>Getting Started: Creating an MCUboot Project</h2>
<p>Start by creating a new project in e2 studio or RA SC. If the MCU supports TrustZone, select a Flat project. The bootloader resides entirely in Secure memory, but it is considered a flat project because it does not provide any Non-Secure Callable functions. On the Stacks tab, add New &gt; Bootloader &gt; MCUboot. Resolve any constraint errors and edit configurations as desired. Add either the example keys or generate your own key. The MCUboot key generation tool is provided at ra/mcu-tools/MCUboot/scripts/imgtool.py and documented at <a href="https://github.com/mcu-tools/mcuboot/blob/master/docs/imgtool.md">https://github.com/mcu-tools/mcuboot/blob/master/docs/imgtool.md</a>. Install the following required python packages to use imgtool.py: <a href="https://github.com/mcu-tools/mcuboot/blob/master/scripts/requirements.txt">https://github.com/mcu-tools/mcuboot/blob/master/scripts/requirements.txt</a>.</p>
<p>In src/hal_entry.c, drag in Developer Assistance &gt; HAL/Common &gt; MCUboot &gt; Quick Setup &gt; Call Quick Setup. Add a call to mcuboot_quick_setup() in the application and make any desired updates.</p>
<dl class="section note"><dt>Note</dt><dd><b>MCUboot will contain either the verificaton public key or its hash. During production it is necessary to permanently lock the flash region where MCUboot is programmed to prevent the keys or the code from being modified.</b></dd></dl>
<h2>Getting Started: Signing Tool Prerequisite</h2>
<p>To use the MCUboot signing tool, ensure you have Python 3.x installed on your system. Then install the Python packages required for the signing tool with the following command:</p>
<p><code>pip3 install --user -r ra/mcu-tools/MCUboot/scripts/requirements.txt</code></p>
<h2>Getting Started: Converting a Project to an MCUboot Image</h2>
<p>MCUboot application images must execute from the image slot defined by the MCUboot project. They are also limited to a single downloadable flash region. All of this is handled by specifying a BootloaderDataFile in the FSP Configuration tool.</p>
<p>Any existing project can be converted to an MCUboot image.</p>
<ol type="1">
<li>If the project was created with a version prior to FSP v3.0.0, update the linker script to the v3.0.0 version before using it as an MCUboot application image.</li>
<li>Right click the project to convert in e2 studio or RA SC and select Properties.</li>
<li>Open C/C++ Build and select Build Variables.</li>
<li>Click Add...</li>
<li>For Variable Name, enter BootloaderDataFile. For Type, select File. Browse to the *.bld file created alongside the *.elf file for the associated MCUboot project.</li>
<li>Click OK, then Apply and Close.</li>
</ol>
<p>To convert a TrustZone image, follow the steps above for both the Secure project and the Non-Secure project.</p>
<p>MCUboot application images must also be signed to work with MCUboot. At a minimum, this involves adding a SHA and MCUboot specific constant data called boot magic in the image trailer.</p>
<p>Signing can be done on the as a post-build step in e2 studio. To sign the image as a post-build step:</p>
<ol type="1">
<li>If Linux is used to develop the application image, change the MCUboot property <code>Signing &gt; Python</code> to <code>python3</code>.</li>
<li>Build the bootloader project to generate the *.bld file. Make sure to build the bootloader project on the same computer as the application image to ensure the path to the signing script is correct.</li>
<li>Define environment variables in the Properties of the application image project in e2 studio.<ol type="a">
<li>Right click the application image project, and select <b>Properties</b>.</li>
<li>Select <b>C/C++ Build &gt; Environment</b> on the left.</li>
<li>Click <b>Add...</b></li>
<li>Define the following environment variables one at a time:<ul>
<li>MCUBOOT_IMAGE_VERSION: Set to the version of the application image.</li>
<li>MCUBOOT_IMAGE_SIGNING_KEY: Set the path to the key used for signing. If signing is not required, do not set this variable. If example keys are used, set MCUBOOT_IMAGE_SIGNING_KEY as follows (replace &lt;boot_project&gt; with the bootloader project path):<ul>
<li>ECC: &lt;boot_project&gt;/ra/mcu-tools/MCUboot/root-ec-p256.pem</li>
<li>RSA 2K: &lt;boot_project&gt;/ra/mcu-tools/MCUboot/root-rsa-2048.pem</li>
<li>RSA 3K: &lt;boot_project&gt;/ra/mcu-tools/MCUboot/root-rsa-3072.pem</li>
</ul>
</li>
<li>MCUBOOT_APP_BIN_CONVERTER: Optional. Set to path to objcopy, arm-none-eabi-objcopy, fromelf, or ielftool. Not required if one of these tools is on the path.</li>
</ul>
</li>
</ol>
</li>
<li>Build the project.</li>
<li>The signed image is output next to the application &lt;project&gt;.elf file with the name &lt;project&gt;bin.signed.</li>
</ol>
<h2>Getting Started: Download and Debug</h2>
<p>For projects that do not use TrustZone, debug the MCUboot project using the default configuration. Before running, load the signed image to the address specified in the signing comment in ra_cfg/mcu-tools/include/mcuboot_config/mcuboot_config.h. This can be done with the Load Ancillary File button when debugging in e2 studio. Upgrade images can be loaded to the upgrade image slots using the same method.</p>
<p>For TrustZone projects, debug using the Secure project to ensure the IDAU is partitioned correctly when debugging in e2 studio. Make the following modifications before debugging in e2 studio:</p>
<ol type="1">
<li>In the Debug Configurations for your project, on the Startup tab, click Add... to add the MCUboot project *.elf file (Image and Symbols), and optionally the Non-Secure project *.elf file.</li>
<li>For the Secure and Non-Secure project *.elf file, load Symbols Only.</li>
<li>After starting to debug, load the signed Secure image and the signed Non-Secure image into the addresses specified in the signing comment in ra_cfg/mcu-tools/include/mcuboot_config/mcuboot_config.h. This can be done with the Load Ancillary File button when debugging in e2 studio. Upgrade images can be loaded to the upgrade image slots using the same method.</li>
</ol>
<h2>Confirming Upgrade in Swap Mode</h2>
<p>In Swap Mode operation, if the upgrade image is signed with the &ndash;pad option, MCUboot will install that image as a temporary update where if nothing else is done, a reboot will cause MCUboot to revert to the image version that was swapped out during the upgrade. In order for the updated image to prevent this reversion and make the update permanent, the boot_set_confirmed() must be called from the application.</p>
<p>To avail this capability in the application image, from the Stacks tab, add New &gt; Bootloader &gt; MCUboot Image Utilities (Swap Mode). Resolve any constraint errors and edit configurations as desired.</p>
<p>In src/hal_entry.c, drag in Developer Assistance &gt; HAL/Common &gt; MCUboot Image Utilities &gt; Quick Setup &gt; Confirm Primary Image. Add a call to boot_set_confirmed() in the application and confirm the image in the primary slot.</p>
<h2>MCUboot Memory Map</h2>
<p>For single image projects, the default memory map looks like:</p>
<div class="image">
<object type="image/svg+xml" data="rm_mcuboot_port_map.svg">rm_mcuboot_port_map.svg</object>
<div class="caption">
MCUboot Memory Map</div></div>
<p> For projects with 2 separately updateable images (used for TrustZone applications where the Secure and Non-Secure images can be updated separately), the default memory map looks like:</p>
<div class="image">
<object type="image/svg+xml" data="rm_mcuboot_port_map_tz.svg">rm_mcuboot_port_map_tz.svg</object>
<div class="caption">
MCUboot Memory Map (TrustZone)</div></div>
 <h2>MCUboot Crypto Stack Options</h2>
<p>The following crypto stacks can be used with MCUboot in FSP:</p><ol type="1">
<li>MbedTLS, which is hardware accelerated on all RA devices. On the RA2 which has an AES engine only, ECC/RSA/SHA operations are in software.</li>
<li>TinyCrypt (S/W Only) can be used with all devices.</li>
<li>TinyCrypt (H/W Accelerated) has AES operations accelerated for the RA2 family only. When using MCUboot without encryption there is no difference between using this or the S/W only version.</li>
<li>SCE9 Protected Mode on devices that have the SCE9 (eg: RA6M4, RA4M3, RA4M2)</li>
</ol>
<p>MbedTLS provides the best performance for MCUBoot signature verification on the RA6 and RA4 devices but has a much larger code footprint compared to TinyCrypt. For RA2 devices TinyCrypt is the best option.</p>
<h2>Using SCE9 Protected Mode Crypto Stack</h2>
<p>Using this crypto stack with MCUBoot provides additional security by ensuring that any keys that are used were securely provisioned for the specific device. The Application Note R11AN0496 provides detailed steps on how to go about installing these keys. Since the section "Preparing Keys for Installation and Update Using RFP" document currently only provides information on how to install an AES key, this section will provide information on how to install an ECC public key.</p>
<dl class="section note"><dt>Note</dt><dd><b>When using the SCE9 Protected Mode Stack with MCUboot it is required that the public keys in the format described in the "MCUboot Example Keys" module in the stack is also provided in the project.</b></dd></dl>
<ol type="1">
<li>Generate an ECC key pair. There are various ways to do this but you can use openSSL to do so: "openssl ecparam -name secp256k1 -genkey -noout -out my_ecc_secp256k1_key.pem".</li>
<li>Once the key is generated, in order to install the public key using RFP (Renesas Flash Programmer) the user needs to have their own UFPK (User Factory Programming Key) and W-UFPK (Wrapped User Factory Programming Key). Refer to R11AN0496 on how to obtain these keys.</li>
<li>Once the UFPK and W-UFPK are available, we need to extract the public key from the pem file. The public key can be viewed by using "openssl ec -noout -text -in my_ecc_secp256k1_key.pem". Note that when the ECC public key is printed out this way, it will contain a 0x04 ASN.1 demarcator at the start which should be discarded.</li>
<li>Use the rfp-util.exe utility from the RFP installation folder to wrap the public key using the UFPK and W-UFPK into a format that can be installed by RFP and the factory bootloader on the MCU.</li>
<li>Use RFP as described in R11AN0496 to install the key to the location of mcuboot_sce9_key section.</li>
</ol>
<p>These are examples that install the default keys provided with MCUboot in ra/mcu-tools/MCUboot/. The examples assume that UFPK nd W-UFPK are already available.</p>
<div class="fragment"><div class="line">  //Print out the EC-P256 Public Key using openSSL</div><div class="line">C:\ openssl ec -noout -text -in root-ec-p256.pem</div><div class="line"></div><div class="line">read EC key</div><div class="line">Private-Key: (256 bit)</div><div class="line">priv:</div><div class="line">    d7:98:d5:2f:83:01:24:3b:d3:54:2b:7e:55:ed:4c:</div><div class="line">    74:61:19:00:b0:f9:50:5a:82:4f:e1:e8:ec:06:3b:</div><div class="line">    cf:f1</div><div class="line">pub:</div><div class="line">    04:2a:cb:40:3c:e8:fe:ed:5b:a4:49:95:a1:a9:1d:</div><div class="line">    ae:e8:db:be:19:37:cd:14:fb:2f:24:57:37:e5:95:</div><div class="line">    39:88:d9:94:b9:d6:5a:eb:d7:cd:d5:30:8a:d6:fe:</div><div class="line">    48:b2:4a:6a:81:0e:e5:f0:7d:8b:68:34:cc:3a:6a:</div><div class="line">    fc:53:8e:fa:c1</div><div class="line">ASN1 OID: prime256v1</div><div class="line">NIST CURVE: P-256</div><div class="line"></div><div class="line">//Use the public key (ignore the 0x04 ASN.1 demarcator) in the RFP command line to convert the public key into an installable format</div><div class="line">C:\ &quot;C:\Program Files (x86)\Renesas Electronics\Programming Tools\Renesas Flash Programmer V3.08\rfp-util.exe&quot; /genkey /ufpk &quot;C:\ufpk.key&quot; /wufpk &quot;C:\ufpk.key_enc.key&quot; /key &quot;2acb403ce8feed5ba44995a1a91daee8dbbe1937cd14fb2f245737e5953988d994b9d65aebd7cdd5308ad6fe48b24a6a810ee5f07d8b6834cc3a6afc538efac1&quot; /userkey &quot;16&quot; /output &quot;C:\ECC_pub_install.rkey&quot;</div><div class="line"></div><div class="line">// From the bootloader map file determine the address of mcuboot_sce9_key section</div><div class="line">Use RFP to install &quot;ECC_pub_install.rkey&quot; as described in R11AN0496 to the address where the mcuboot_sce9_key section is located.</div></div><!-- fragment --><h2>Limitations</h2>
<p>MCUboot tooling updates to adjust available flash in application images are currently only supported for the GCC compiler. IAR and AC6 support will be added in a future release.</p>
<h1><a class="anchor" id="r-mcuboot-port-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is an example of using MCUboot in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> rm_mcuboot_port_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef MCUBOOT_USE_MBED_TLS</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize mbedtls. */</span></div><div class="line">    <a class="code" href="structmbedtls__platform__context.html">mbedtls_platform_context</a> ctx = {0};</div><div class="line">    assert(0 == <a class="code" href="group___r_m___p_s_a___c_r_y_p_t_o.html#gaf0f37c11be234650bec95ce37e9a4a6b">mbedtls_platform_setup</a>(&amp;ctx));</div><div class="line"><span class="preprocessor">#elif defined(MCUBOOT_USE_TINYCRYPT)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize TinyCrypt port. */</span></div><div class="line">    assert(FSP_SUCCESS == <a class="code" href="group___r_m___t_i_n_y_c_r_y_p_t___p_o_r_t.html#gaaff886271ad29c31a3c148b6d4bd0f92">RM_TINCYRYPT_PORT_Init</a>());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line"></div><div class="line">    <span class="comment">/* Initialize SCE9 Protected Mode driver. */</span></div><div class="line">    <a class="code" href="group___s_c_e___p_r_o_t_e_c_t_e_d.html#structsce__instance__ctrl__t">sce_instance_ctrl_t</a> sce_ctrl;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___s_c_e___p_r_o_t_e_c_t_e_d___a_p_i.html#structsce__cfg__t">sce_cfg_t</a>     sce_cfg =</div><div class="line">    {.<a class="code" href="group___s_c_e___p_r_o_t_e_c_t_e_d___a_p_i.html#a9293397005f7f38d4872a61932e30760">lifecycle</a> = SCE_SSD};</div><div class="line">    assert(FSP_SUCCESS == <a class="code" href="group___s_c_e___p_r_o_t_e_c_t_e_d.html#gae41c48db65491a6884039929b6734557">R_SCE_Open</a>(&amp;sce_ctrl, &amp;sce_cfg));</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) To check for updates, call boot_set_pending. */</span></div><div class="line">    <span class="keywordtype">bool</span> update = 0;</div><div class="line">    <span class="keywordflow">if</span> (update)</div><div class="line">    {</div><div class="line">        boot_set_pending(0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Verify the boot image and get its location. */</span></div><div class="line">    <span class="keyword">struct </span>boot_rsp rsp;</div><div class="line">    assert(0 == boot_go(&amp;rsp));</div><div class="line"></div><div class="line">    <span class="comment">/* Enter the application. */</span></div><div class="line">    RM_MCUBOOT_PORT_BootApp(&amp;rsp);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.4.0 User's Manual Copyright © (2021) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
