<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Independent Watchdog Timer (r_iwdt)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v1.1.1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___i_w_d_t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Independent Watchdog Timer (r_iwdt)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga74e708a8e45b1b93b2a9255d50007a4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl)</td></tr>
<tr class="separator:ga74e708a8e45b1b93b2a9255d50007a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga989ac08697fdbf8a0ca02f8fd3066080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:ga989ac08697fdbf8a0ca02f8fd3066080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4ac4abef1b4d4b3dd2982bc1b19278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status)</td></tr>
<tr class="separator:gaca4ac4abef1b4d4b3dd2982bc1b19278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9619fc0daddf190cda28ccae1213629d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga9619fc0daddf190cda28ccae1213629d">R_IWDT_StatusGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const p_status)</td></tr>
<tr class="separator:ga9619fc0daddf190cda28ccae1213629d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e86ba83718eb70e72bfb892c39ddbb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga5e86ba83718eb70e72bfb892c39ddbb4">R_IWDT_CounterGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, uint32_t *const p_count)</td></tr>
<tr class="separator:ga5e86ba83718eb70e72bfb892c39ddbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e029c3f446f09d7de668eb49709b439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga7e029c3f446f09d7de668eb49709b439">R_IWDT_TimeoutGet</a> (<a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const p_api_ctrl, <a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const p_timeout)</td></tr>
<tr class="separator:ga7e029c3f446f09d7de668eb49709b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16b1037e3a48398170eb28a5f6f8565f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ga16b1037e3a48398170eb28a5f6f8565f">R_IWDT_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_data)</td></tr>
<tr class="separator:ga16b1037e3a48398170eb28a5f6f8565f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the IWDT peripheral on RA MCUs. This module implements the <a class="el" href="group___w_d_t___a_p_i.html">WDT Interface</a>. </p>
<h1><a class="anchor" id="r-iwdt-overview"></a>
Overview</h1>
<p>The independent watchdog timer is used to recover from unexpected errors in an application. The timer must be refreshed periodically in the permitted count window by the application. If the count is allowed to underflow or refresh occurs outside of the valid refresh period, the IWDT resets the device or generates an NMI.</p>
<h2><a class="anchor" id="r-iwdt-features"></a>
Features</h2>
<p>The IWDT HAL module has the following key features:</p><ul>
<li>When the IWDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:<ul>
<li>Resetting of the device</li>
<li>Generation of an NMI<a class="anchor" id="um_wdt_nmi_callback_support"></a></li>
</ul>
</li>
<li>The IWDT begins counting at reset.<a class="anchor" id="um_wdt_auto_start_mode_support"></a></li>
</ul>
<h2><a class="anchor" id="r-iwdt-selecting-a-watchdog"></a>
Selecting a Watchdog</h2>
<p>RA MCUs have two watchdog peripherals: the watchdog timer (WDT) and the independent watchdog timer (IWDT). When selecting between them, consider these factors:</p>
<table class="doxtable">
<tr>
<th></th><th>WDT </th><th>IWDT  </th></tr>
<tr>
<td>Start Mode</td><td>The WDT can be started from the application (register start mode) or configured by hardware to start automatically (auto start mode). </td><td>The IWDT can only be configured by hardware to start automatically. </td></tr>
<tr>
<td>Clock Source</td><td>The WDT runs off a peripheral clock.</td><td>The IWDT has its own clock source which improves safety. </td></tr>
</table>
<h1><a class="anchor" id="r-iwdt-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_wdt_nmi_callback_required"></a> <h2>Build Time Configurations for r_iwdt</h2>
The following build time configurations are defined in fsp_cfg/r_iwdt_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for Driver &gt; Monitoring &gt; Watchdog Driver on r_iwdt</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; Monitoring &gt; Watchdog Driver on r_iwdt:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Name</td><td>Name must be a valid C symbol</td><td>g_wdt0 </td><td>Module name. </td></tr>
<tr>
<td>NMI callback</td><td>Name must be a valid C symbol</td><td>NULL </td><td>A user callback function can be provided here. If this callback function is provided, it is called from the interrupt service routine (ISR) when the watchdog triggers. </td></tr>
</table>
</p>
<dl class="section note"><dt>Note</dt><dd>The IWDT has additional configurable settings in the OFS0 register in the <b>BSP</b> tab properties window. These settings include the following:<ul>
<li>Start Mode</li>
<li>Timeout Period</li>
<li>Dedicated Clock Frequency Divisor</li>
<li>Window End Position</li>
<li>Window Start Position</li>
<li>Reset Interrupt Request Select</li>
<li>Stop Control</li>
</ul>
</dd>
<dd>
Review the OFS0 properties window to see additional details.</dd></dl>
<h2><a class="anchor" id="r-iwdt-clock-configuration"></a>
Clock Configuration</h2>
<p>The IWDT clock is based on the IWDTCLK frequency. You can set the IWDTCLK frequency divider using the <b>BSP</b> tab of the RA Configuration editor.</p>
<h2><a class="anchor" id="r-iwdt-pin-configuration"></a>
Pin Configuration</h2>
<p>This module does not use I/O pins.</p>
<h1><a class="anchor" id="r-iwdt-usage_notes"></a>
Usage Notes</h1>
<h2><a class="anchor" id="r-iwdt-nmi-interrupt"></a>
NMI Interrupt</h2>
<p>The independent watchdog timer uses the NMI, which is enabled by default. No special configuration is required. When the NMI is triggered, the callback function registered during open is called.</p>
<h2>Period Calculation</h2>
<p>The IWDT operates from IWDTCLK. With a IWDTCLK of 15000 Hz, the maximum time from the last refresh to device reset or NMI generation will be just below 35 seconds as detailed below.</p>
<p>IWDTCLK = 15000 Hz<br />
Clock division ratio = IWDTCLK / 256<br />
Timeout period = 2048 cycles<br />
WDT clock frequency = 15000 Hz / 256 = 58.59 Hz<br />
Cycle time = 1 / 58.59 Hz = 17.067 ms<br />
Timeout = 17.067 ms x 2048 cycles = 34.95 seconds</p>
<h2><a class="anchor" id="r-iwdt-limitations"></a>
Limitations</h2>
<p>Developers should be aware of the following limitations when using the IWDT:</p>
<ul>
<li>When using a J-Link debugger the IWDT counter does not count and therefore will not reset the device or generate an NMI. To enable the watchdog to count and generate a reset or NMI while debugging, add this line of code in the application: <div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Enable the IWDT to count and generate NMI or reset when the</span></div><div class="line"><span class="comment">     * debugger is connected. */</span></div><div class="line">    R_DEBUG-&gt;DBGSTOPCR_b.DBGSTOP_IWDT = 0;</div><div class="line"></div></div><!-- fragment --></li>
<li>If the IWDT is configured to stop the counter in low power mode, then your application must restart the watchdog by calling <a class="el" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh()</a> after the MCU wakes from low power mode.</li>
</ul>
<h1><a class="anchor" id="r-iwdt-examples"></a>
Examples</h1>
<h2>IWDT Basic Example</h2>
<p>This is a basic example of minimal use of the IWDT in an application.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> iwdt_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* In auto start mode, the IWDT starts counting immediately when the MCU is powered on. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a>(&amp;g_iwdt0_ctrl, &amp;g_iwdt0_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI based on the setting. */</span></div><div class="line">        (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line"></div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>IWDT Advanced Example</h2>
<p>This example demonstrates using a start window and gives an example callback to handle an NMI generated by an underflow or refresh error.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define IWDT_TIMEOUT_COUNTS     (2048U)</span></div><div class="line"><span class="preprocessor">#define IWDT_MAX_COUNTER        (IWDT_TIMEOUT_COUNTS - 1U)</span></div><div class="line"><span class="preprocessor">#define IWDT_START_WINDOW_75    ((IWDT_MAX_COUNTER * 3) / 4)</span></div><div class="line"></div><div class="line"><span class="comment">/* Example callback called when a watchdog NMI occurs. */</span></div><div class="line"><span class="keywordtype">void</span> iwdt_callback (<a class="code" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gaf0afcbc9a110ac9366a811d96ee06029">FSP_PARAMETER_NOT_USED</a>(p_args);</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga9619fc0daddf190cda28ccae1213629d">R_IWDT_StatusGet</a>(&amp;g_iwdt0_ctrl, &amp;status);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Log source of NMI and any other debug information. */</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a>(&amp;g_iwdt0_ctrl, status);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Issue a software reset to reset the MCU. */</span></div><div class="line">    __NVIC_SystemReset();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> iwdt_advanced_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Enable the IWDT to count and generate NMI or reset when the</span></div><div class="line"><span class="comment">     * debugger is connected. */</span></div><div class="line">    R_DEBUG-&gt;DBGSTOPCR_b.DBGSTOP_IWDT = 0;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Check if the IWDTRF flag is set to know if the system is</span></div><div class="line"><span class="comment">     * recovering from a IWDT reset. */</span></div><div class="line">    <span class="keywordflow">if</span> (R_SYSTEM-&gt;RSTSR1_b.IWDTRF)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Clear the flag. */</span></div><div class="line">        R_SYSTEM-&gt;RSTSR1 = 0U;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Open the module. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a>(&amp;g_iwdt0_ctrl, &amp;g_iwdt0_cfg);</div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize other application code. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Do not call R_IWDT_Refresh() in auto start mode unless the</span></div><div class="line"><span class="comment">     * counter is in the acceptable refresh window. */</span></div><div class="line">    (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Application work here. */</span></div><div class="line"></div><div class="line">        <span class="comment">/* (Optional) If there is a chance the application takes less time than</span></div><div class="line"><span class="comment">         * the start window, verify the IWDT counter is past the start window</span></div><div class="line"><span class="comment">         * before refreshing the IWDT. */</span></div><div class="line">        uint32_t iwdt_counter = 0U;</div><div class="line">        <span class="keywordflow">do</span></div><div class="line">        {</div><div class="line"></div><div class="line">            <span class="comment">/* Read the current IWDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___i_w_d_t.html#ga5e86ba83718eb70e72bfb892c39ddbb4">R_IWDT_CounterGet</a>(&amp;g_iwdt0_ctrl, &amp;iwdt_counter);</div><div class="line">            handle_error(err);</div><div class="line"></div><div class="line">        } <span class="keywordflow">while</span> (iwdt_counter &gt;= IWDT_START_WINDOW_75);</div><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI. */</span></div><div class="line">        (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structiwdt__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#structiwdt__instance__ctrl__t">iwdt_instance_ctrl_t</a></td></tr>
<tr class="separator:structiwdt__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structiwdt__instance__ctrl__t" id="structiwdt__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structiwdt__instance__ctrl__t">&#9670;&nbsp;</a></span>iwdt_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct iwdt_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>IWDT control block. DO NOT INITIALIZE. Initialization occurs when <a class="el" href="group___w_d_t___a_p_i.html#af03fc1703319e1adacabc412c7e3de31">wdt_api_t::open</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:ae07ff8e66ee64e231841e8a578b76eff"><td class="memItemLeft" align="right" valign="top"><a id="ae07ff8e66ee64e231841e8a578b76eff"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#ae07ff8e66ee64e231841e8a578b76eff">wdt_open</a></td></tr>
<tr class="memdesc:ae07ff8e66ee64e231841e8a578b76eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the open() API has been successfully called. <br /></td></tr>
<tr class="separator:ae07ff8e66ee64e231841e8a578b76eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10f9877b3a8b1aaee8a9a422f1398f3"><td class="memItemLeft" align="right" valign="top"><a id="af10f9877b3a8b1aaee8a9a422f1398f3"></a>
void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#af10f9877b3a8b1aaee8a9a422f1398f3">p_context</a></td></tr>
<tr class="memdesc:af10f9877b3a8b1aaee8a9a422f1398f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. Passed to the user callback in <a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a>. <br /></td></tr>
<tr class="separator:af10f9877b3a8b1aaee8a9a422f1398f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aa382d6d5bd479c938e8d3783a1080"><td class="memItemLeft" align="right" valign="top"><a id="a14aa382d6d5bd479c938e8d3783a1080"></a>
R_IWDT_Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#a14aa382d6d5bd479c938e8d3783a1080">p_reg</a></td></tr>
<tr class="memdesc:a14aa382d6d5bd479c938e8d3783a1080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to register base address. <br /></td></tr>
<tr class="separator:a14aa382d6d5bd479c938e8d3783a1080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1051de77f0a7903177849ae4df6729ec"><td class="memItemLeft" align="right" valign="top"><a id="a1051de77f0a7903177849ae4df6729ec"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_w_d_t.html#a1051de77f0a7903177849ae4df6729ec">p_callback</a> )(<a class="el" href="group___w_d_t___a_p_i.html#structwdt__callback__args__t">wdt_callback_args_t</a> *p_args)</td></tr>
<tr class="memdesc:a1051de77f0a7903177849ae4df6729ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback provided when a WDT NMI ISR occurs. <br /></td></tr>
<tr class="separator:a1051de77f0a7903177849ae4df6729ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga74e708a8e45b1b93b2a9255d50007a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74e708a8e45b1b93b2a9255d50007a4d">&#9670;&nbsp;</a></span>R_IWDT_Refresh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_Refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refresh the Independent Watchdog Timer. If the refresh fails due to being performed outside of the permitted refresh period the device will either reset or trigger an NMI ISR to run.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">        <span class="comment">/* Refresh before the counter underflows to prevent reset or NMI based on the setting. */</span></div><div class="line">        (void) <a class="code" href="group___i_w_d_t.html#ga74e708a8e45b1b93b2a9255d50007a4d">R_IWDT_Refresh</a>(&amp;g_iwdt0_ctrl);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT successfully refreshed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>One or more parameters are NULL pointers. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga989ac08697fdbf8a0ca02f8fd3066080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga989ac08697fdbf8a0ca02f8fd3066080">&#9670;&nbsp;</a></span>R_IWDT_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__cfg__t">wdt_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register the IWDT NMI callback.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open</a>(&amp;g_iwdt0_ctrl, &amp;g_iwdt0_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null Pointer. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_ENABLED</td><td>An attempt to open the IWDT when the OFS0 register is not configured for auto-start mode. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca4ac4abef1b4d4b3dd2982bc1b19278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4ac4abef1b4d4b3dd2982bc1b19278">&#9670;&nbsp;</a></span>R_IWDT_StatusClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_StatusClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the IWDT status and error flags. Implements <a class="el" href="group___w_d_t___a_p_i.html#af66d798489c7ace801fee8b5a9c833c2">wdt_api_t::statusClear</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Clear the error flags. */</span></div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#gaca4ac4abef1b4d4b3dd2982bc1b19278">R_IWDT_StatusClear</a>(&amp;g_iwdt0_ctrl, status);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT flag(s) successfully cleared. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9619fc0daddf190cda28ccae1213629d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9619fc0daddf190cda28ccae1213629d">&#9670;&nbsp;</a></span>R_IWDT_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> *const&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the IWDT status flags. When the IWDT is configured to output a reset on underflow or refresh error reading the status and error flags can be read after reset to establish if the IWDT caused the reset. Reading the status and error flags in NMI output mode indicates whether the IWDT generated the NMI interrupt.</p>
<p>Indicates both status and error conditions.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/* (Optional) Determine the source of the NMI. */</span></div><div class="line">    <a class="code" href="group___w_d_t___a_p_i.html#ga46c1d04f78b75ad1ad21314cac574935">wdt_status_t</a> status = <a class="code" href="group___w_d_t___a_p_i.html#gga46c1d04f78b75ad1ad21314cac574935a0f1543f47bca7e987fe86ab04dd16e46">WDT_STATUS_NO_ERROR</a>;</div><div class="line">    err = <a class="code" href="group___i_w_d_t.html#ga9619fc0daddf190cda28ccae1213629d">R_IWDT_StatusGet</a>(&amp;g_iwdt0_ctrl, &amp;status);</div><div class="line">    handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT status successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e86ba83718eb70e72bfb892c39ddbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e86ba83718eb70e72bfb892c39ddbb4">&#9670;&nbsp;</a></span>R_IWDT_CounterGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_CounterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the current count value of the IWDT. Implements <a class="el" href="group___w_d_t___a_p_i.html#a724c02d7265d5eaa846cf97a3556f5d6">wdt_api_t::counterGet</a>.</p>
<p>Example: </p><div class="fragment"><div class="line"></div><div class="line">            <span class="comment">/* Read the current IWDT counter value. */</span></div><div class="line">            err = <a class="code" href="group___i_w_d_t.html#ga5e86ba83718eb70e72bfb892c39ddbb4">R_IWDT_CounterGet</a>(&amp;g_iwdt0_ctrl, &amp;iwdt_counter);</div><div class="line">            handle_error(err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT current count successfully read. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e029c3f446f09d7de668eb49709b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e029c3f446f09d7de668eb49709b439">&#9670;&nbsp;</a></span>R_IWDT_TimeoutGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_TimeoutGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#gacb273fc13cd5efef455f45486b436efe">wdt_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___w_d_t___a_p_i.html#structwdt__timeout__values__t">wdt_timeout_values_t</a> *const&#160;</td>
          <td class="paramname"><em>p_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read timeout information for the watchdog timer. Implements <a class="el" href="group___w_d_t___a_p_i.html#ac2b6d848e8be0ff1a0a1be43289ad925">wdt_api_t::timeoutGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>IWDT timeout information retrieved successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>One or more parameters are NULL pointers. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The driver has not been opened. Perform <a class="el" href="group___i_w_d_t.html#ga989ac08697fdbf8a0ca02f8fd3066080">R_IWDT_Open()</a> first. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16b1037e3a48398170eb28a5f6f8565f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b1037e3a48398170eb28a5f6f8565f">&#9670;&nbsp;</a></span>R_IWDT_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_IWDT_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return IWDT HAL driver version. Implements <a class="el" href="group___w_d_t___a_p_i.html#a68032fbfd5bf74052918b358be31b219">wdt_api_t::versionGet</a>.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Call successful. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v1.1.1 User's Manual Copyright © (2020) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
