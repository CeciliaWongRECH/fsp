<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Capacitive Touch Sensing Unit (r_ctsu)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <script type="text/javascript" src="search/lunr.js"></script>
    <link href="search/lunrsearch.css" rel="stylesheet" type="text/css">
    <script src="search/lunr_index.js"></script>
    <script src="search/lunrclient.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v3.1.0</span>
   </div>
  </td>
   <td>        <br /><div id="MSearchBox" class="MSearchBoxInactive">
 
    <form id="lunrSearchForm" name="lunrSearchForm">
      <span class="left" >
          <img id="MSearchSelect" src="search/mag_sel.png"
               alt=""/>
         <input class="search-input" id="MSearchField" name="q" placeholder="Search" type="text"> 
      </span>
      <span class="right">
          &nbsp; 
      </span>
        <!--<input type="submit" value="Search">-->
    </form>
</div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___c_t_s_u.html','');});
</script>

<script src="search/mark.min.js"></script>
<script type="text/javascript">
  $(document).ready(function() { 
    var options = {         // allows highlighting across element boundaries.
      "acrossElements": true
    };
    var bodyText = $("div.contents").text(); // try contents instead of body. 
    // If using body: Problem may be that text inside <script> tags is included in .text() - but not in cheerio?
    // If using div.contents - works 
    var fullURL = $(location).attr('href');
    var splitURL = fullURL.split("?");  // Get param string: content after "?" in URL
    if (splitURL.length > 1) {          // If any content after "?"
      var paramStr = splitURL[1];
      var params = paramStr.split("&"); // Split params on "&"
      for (i = 0; i < params.length; i++) {
        var paramPair = params[i].split("=");
        if (paramPair[0] == "pos") {     // If any param starts "pos", get the content after "="
          posStr = paramPair[1];
          var splitPos = posStr.split(",");
          var termArray = [];
        // termArray will have the search terms
            for (i=0; i < splitPos.length; i += 2) {
            start = splitPos[i];
            len = splitPos[i+1]; // Needs error detection! Vulnerable if non-even # of pos entries
            term = bodyText.substr(start,len);
            if (termArray.includes(term) == false) {     // List all unique terms
                termArray.push(bodyText.substr(start,len)); 
            }
          } 
    //      console.log(termArray);
          var context = document.querySelector("div.contents");
          var instance = new Mark(context);
          for(i=0;i<termArray.length; i+=1) {
            instance.mark(termArray[i],options);  // Use Mark.js to mark all terms in termArray
            }    
          var firstMark = document.querySelector("mark");
          firstMark.scrollIntoView(true);
          //      console.log($("mark").first().text()); // Trying to scroll to first Mark element. 
        }
            }
    }
  });
</script>

<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />

<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


<!-- Lunr search results -->
<div id="lunrResultBox" style="
        position: fixed;
        border: 1px solid black;
        background-color: WhiteSmoke;  
        padding: 10px;
        width: 500px;
        height: 500px;
        top: 30;
        right: 0;
        overflow: auto;
        display: none">
    <button onclick="closeLunrResults()" style="float: right;">X</button>
    <div class="resultCount" id="resultCount"></div>
    <div id="searchResults"></div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Capacitive Touch Sensing Unit (r_ctsu)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4e625d8c9f3b301a46913c5827732682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="memdesc:ga4e625d8c9f3b301a46913c5827732682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens and configures the CTSU driver module. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ae8f2c7b3cc9e33f0f790f76655d3d723">ctsu_api_t::open</a>.  <a href="#ga4e625d8c9f3b301a46913c5827732682">More...</a><br /></td></tr>
<tr class="separator:ga4e625d8c9f3b301a46913c5827732682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cf185922bbca921cb92b4c18f62525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga46cf185922bbca921cb92b4c18f62525"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called each time a periodic timer expires. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Before starting the next scan, first get the data with <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. If a different control block scan should be run, check the scan is complete before executing. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a1df87278ab5d47fdd093994f53de96a6">ctsu_api_t::scanStart</a>.  <a href="#ga46cf185922bbca921cb92b4c18f62525">More...</a><br /></td></tr>
<tr class="separator:ga46cf185922bbca921cb92b4c18f62525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl, uint16_t *p_data)</td></tr>
<tr class="memdesc:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aadcc6930b4e9d0ad86b6f607e86c28f5">ctsu_api_t::dataGet</a>.  <a href="#ga1cff42feeaa3d73216b73c313fb9a5fe">More...</a><br /></td></tr>
<tr class="separator:ga1cff42feeaa3d73216b73c313fb9a5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c966546f3774ce2228739a5ffc0ac19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga3c966546f3774ce2228739a5ffc0ac19">R_CTSU_CallbackSet</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_api_ctrl, void(*p_callback)(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *), void const *const p_context, <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *const p_callback_memory)</td></tr>
<tr class="separator:ga3c966546f3774ce2228739a5ffc0ac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagnosis the CTSU peripheral. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a42a81fef42f2bf61bde59cba4796cc0e">ctsu_api_t::diagnosis</a>.  <a href="#ga45103e8db4a16dfabf3a516ab2da9f26">More...</a><br /></td></tr>
<tr class="separator:ga45103e8db4a16dfabf3a516ab2da9f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b45020c568d57065c8a7adecaaeb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga73b45020c568d57065c8a7adecaaeb4c">R_CTSU_Close</a> (<a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const p_ctrl)</td></tr>
<tr class="memdesc:ga73b45020c568d57065c8a7adecaaeb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables specified CTSU control block. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aeb44bb4a59bad9025f0897cee306a395">ctsu_api_t::close</a>.  <a href="#ga73b45020c568d57065c8a7adecaaeb4c">More...</a><br /></td></tr>
<tr class="separator:ga73b45020c568d57065c8a7adecaaeb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This HAL driver supports the Capacitive Touch Sensing Unit (CTSU). It implements the <a class="el" href="group___c_t_s_u___a_p_i.html">CTSU Interface</a>. </p>
<h1><a class="anchor" id="r-ctsu-overview"></a>
Overview</h1>
<p>The capacitive touch sensing unit HAL driver (r_ctsu) provides an API to control the CTSU peripheral. This module performs capacitance measurement based on various settings defined by the configuration. This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>.</p>
<h2><a class="anchor" id="r-ctsu-features"></a>
Features</h2>
<p><a class="anchor" id="um_ctsu_mutual"></a><a class="anchor" id="um_ctsu_multi_method"></a></p><ul>
<li>Supports both Self-capacitance multi scan mode and Mutual-capacitance full scan mode</li>
<li>Scans may be started by software or an external trigger</li>
<li>Returns measured capacitance data on scan completion</li>
<li>Optional DTC support</li>
</ul>
<h1><a class="anchor" id="r-ctsu-configuration"></a>
Configuration</h1>
<dl class="section note"><dt>Note</dt><dd><b>This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>. For information on how to use the QE tool, once the tool is installed click Help -&gt; Help Contents in e2 studio and search for "QE".</b></dd></dl>
<p><h2>Build Time Configurations for r_ctsu</h2>
The following build time configurations are defined in fsp_cfg/r_ctsu_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Default (BSP)</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Default (BSP) </td><td>If selected code for parameter checking is included in the build. </td></tr>
<tr>
<td>Support for using DTC</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>Disabled </td><td>Enable DTC support for the CTSU module. </td></tr>
<tr>
<td>Interrupt priority level</td><td>MCU Specific Options</td><td></td><td>Priority level of all CTSU interrupt (CSTU_WR,CTSU_RD,CTSU_FN)  </td></tr>
</table>
 <h2>Configurations for Driver &gt; CapTouch &gt; CTSU Driver on r_ctsu</h2>
This module can be added to the Stacks tab via New Stack &gt; Driver &gt; CapTouch &gt; CTSU Driver on r_ctsu. Non-secure callable guard functions can be generated for this module by right clicking the module in the RA Configuration tool and checking the "Non-secure Callable" box.<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Default</th><th>Description </th></tr>
<tr>
<td>Scan Start Trigger</td><td>MCU Specific Options</td><td></td><td>CTSU Scan Start Trigger Select </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-ctsu-interrupt-configuration"></a>
Interrupt Configuration</h2>
<p>The first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> function call sets CTSU peripheral interrupts. The user should provide a callback function to be invoked at the end of the CTSU scan sequence. The callback argument will contain information about the scan status.</p>
<h2><a class="anchor" id="r-ctsu-clock-configuration"></a>
Clock Configuration</h2>
<p>The CTSU peripheral module uses PCLKB as its clock source. You can set the PCLKB frequency using the <b>Clocks</b> tab of the RA Configuration editor or by using the CGC Interface at run-time.</p>
<dl class="section note"><dt>Note</dt><dd>The CTSU Drive pulse will be calculated and set by the tooling depending on the selected transfer rate.</dd></dl>
<h2><a class="anchor" id="r-ctsu-pin-configuration"></a>
Pin Configuration</h2>
<p>The TSn pins are sensor pins for the CTSU.</p>
<p>The TSCAP pin is used for an internal low-pass filter and must be connected to an external decoupling capacitor.</p>
<h1><a class="anchor" id="r-ctsu-usage_notes"></a>
Usage Notes</h1>
<h2>CTSU</h2>
<h3>Sensor ICO correction</h3>
<p>In order to improve the measurement accuracy, the correction coefficient is generated at the first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>. Therefore, the first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> process takes about 40ms.</p>
<h3>Initial offset tuning</h3>
<p>CTSU has a current offset mechanism to cancel the parasitic capacitance. This module automatically adjusts to be within the dynamic range of the Sensor ICO, taking into account the amount of current that changes with touch. This adjustment uses normal measurement prosess and requires several <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a> and <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>. <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a> returns FSP_ERR_CTSU_INCOMPLETE_TUNING if it is being adjusted. The member "so" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__element__cfg__t">ctsu_element_cfg_t</a> is used as the starting point for adjustment, so if this value is appropriate, it can be completed quickly. Normally, this value uses the value adjusted by QE for Capacitive Touch.</p>
<h3>Scan trigger</h3>
<p>Scanning of sensors may begin by either a software trigger or an external event initiated by the Event Link Controller (ELC). This trigger can be set with the member "cap" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Typically, a software trigger is used. Common usage is to have a periodic timer initiate scans. For software triggers, a periodic timer such as the CMT is configured whose interval is large enough to allow for all sensors to be scanned and data to be updated. Software triggers are issued by calling <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>. Using an external trigger is processed almost identically to using software triggers. Call <a class="el" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a> before starting the timer to set the measurement and prepare for external trigger measurement. After that, when the timer is started, the measurement start trigger is applied.</p>
<h3>Self-capacitance multi scan mode</h3>
<p>In self-capacitance mode each TS pin is assigned to one touch button. Electrodes of multiple TS pins can be physically aligned to create slider or wheel interfaces.</p>
<ul>
<li>Scan Order<ul>
<li>The hardware scans the specified pins in ascending order.</li>
<li>For example, if pins TS05, TS08, TS02, TS03, and TS06 are specified in your application, the hardware will scan them in the order TS02, TS03, TS05, TS06, TS08.</li>
</ul>
</li>
<li>Element<ul>
<li>An element refers to the index of a pin within the scan order. Using the previous example, TS05 is element 2.</li>
</ul>
</li>
<li>Scan Time<ul>
<li>Scanning is handled directly by the CTSU peripheral and does not utilize any main processor time.</li>
<li>It takes approximately 500us to scan a single sensor.</li>
<li>If DTC is not used additional overhead is required for the main processor to transfer data to/from registers when each sensor is scanned.</li>
</ul>
</li>
</ul>
<p>Set CTSU_MODE_SELF_MULTI_SCAN to "md" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Also, add the number of terminals used for this measurement to CTSU_CFG_NUM_SELF_ELEMENTS. For details, refer to the configuration and sample application output by QE for Capacitive Touch.</p>
<h3>Mutual-capacitance full scan mode</h3>
<p>In mutual-capacitance mode each TS pin acts as either a 'row' or 'column' in an array of sensors. As a result, this mode uses fewer pins when more than five sensors are configured. Mutual-capacitance mode is ideal for applications where many touch sensors are required, like keypads, button matrices and pads.</p>
<p>As an example, consider a standard phone keypad comprised of a matrix of four rows and three columns.</p>
<div class="image">
<object type="image/svg+xml" data="r_ctsu_mutual_button.svg">r_ctsu_mutual_button.svg</object>
<div class="caption">
Mutual Button Image</div></div>
<p>)</p>
<p>In mutual capacitance mode only 7 pins are necessary to scan 12 buttons. In self mode, 12 pins would be required.</p>
<ul>
<li>Scan Order<ul>
<li>The hardware scans the matrix by iterating over the TX pins first and the RX pins second.</li>
<li>For example, if pins TS10, TS11, and TS03 are specified as RX sensors and pins TS02, TS07, and TS04 are specified as TX sensors, the hardware will scan them in the following sensor-pair order:<br />
 TS03-TS02, TS03-TS04, TS03-TS07, TS10-TS02, TS10-TS04, TS10-TS07, TS11-TS02, TS11-TS04, TS11-TS07</li>
</ul>
</li>
<li>Element<ul>
<li>An element refers to the index of a sensor-pair within the scan order. Using the previous example, TS10-TS07 is element 5.</li>
</ul>
</li>
<li>Scan Time<ul>
<li>Because mutual-capacitance scans two patterns for one element it takes twice as long as self-capacitance (1ms vs 0.5ms per element).</li>
</ul>
</li>
</ul>
<p>Set CTSU_MODE_MUTUAL_FULL_SCAN to "md" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Also, add the number of matrix used for this measurement to CTSU_CFG_NUM_MUTUAL_ELEMENTS. For details, refer to the configuration and sample application output by QE for Capacitive Touch.</p>
<h2>CTSU2 (RA2L1)</h2>
<p>CTSU2 is a peripheral that improves CTSU. For CTSU2, this module supports the following in addition to the features described in the CTSU chapter.</p>
<h3>Improved accuracy with more accurate ICO correction</h3>
<p>The internal circuit of CTSU2 is used to create a correction coefficient with higher accuracy than CTSU. This correction coefficient is created by the first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a> like CTSU, but it takes about 100ms. For Mutual-capacitance parallel scan mode, create a correction factor for the CFC circuit. This is also created with the first <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>. It takes about 40ms.</p>
<h3>Improved noise immunity by multi-frequency measurement</h3>
<p>CTSU2 can measure up to 4 different drive frequencies to avoid sync noise. This module sets the number of frequencies with CTSU_CFG_NUM_SUMULTI. The recommended value is 3. The three frequencies are set according to CTSU_CFG_SUMULTI0, CTSU_CFG_SUMULTI1 and CTSU_CFG_SUMULTI2. 0x3F is the center. QE will automatically output the recommended value. From the three results obtained, make a noise removal judgment to determine the measured value. By setting judge_multifreq_disable in <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> to true, it is possible to get three results without making a majority vote and use your own noise filter. Prepare three times as many buffers for the data to be acquired by <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>.</p>
<h3>Mutual-capacitance parallel scan mode</h3>
<p>This mode provides fast measurement time by parallel scanning the RX lines with a CFC circuit. Operation is otherwise identical to normal CTSU mutual scanning.</p>
<ul>
<li>Scan Order<ul>
<li>The hardware scans all RX pins simultaneously for each TX pin.</li>
<li>For example, if sensors TS10, TS11, and TS03 are specified as RX sensors, and sensors TS02, TS07, and TS04 are specified as TX sensors, the hardware will scan them in the following sensor-pair order:<br />
 TS02-(TS03, TS10, TS11), TS04-(TS03, TS10, TS11), TS07-(TS03, TS10, TS11)</li>
</ul>
</li>
<li>Element<ul>
<li>An element refers to the index of a sensor-pair within the scan order. Using the previous example, TS07-TS10 is element 7.</li>
</ul>
</li>
<li>Scan Time<ul>
<li>Because the RX lines are scanned in parallel, CFC mutual-capacitance scan is the same amount of times faster than a basic mutual matrix scan as the number of RX lines. In other words, on a matrix with N receive lines, CFC mutual scanning is N times faster than basic mutual scanning.</li>
</ul>
</li>
</ul>
<p>Set CTSU_MODE_MUTUAL_CFC_SCAN to "md" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Also, add the number of matrix used for this measurement to CTSU_CFG_NUM_MUTUAL_ELEMENTS. In addition, set the number of CTSU_CFG_NUM_CFC and CTSU_CFG_NUM_CFC_TX. For details, refer to the configuration and sample application output by QE for Capacitive Touch.</p>
<h3>Current scan mode</h3>
<p>CTSU2 can measure the current input to the TS terminal. This module supports this feature. Set CTSU_MODE_CURRENT_SCAN to "md" of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a>. Also, add the number of terminals used for this measurement to CTSU_CFG_NUM_SELF_ELEMENTS. For details, refer to the configuration and sample application output by QE for Capacitive Touch.</p>
<h3>Active shield</h3>
<p>CTSU2 can drive a shield signal on a single TS pin. This module can set the shield for each instance. Set the members of <a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> as shown in the example below. Other configurations omitted </p><div class="fragment"><div class="line">.txvsel     = CTSU_TXVSEL_INTERNAL_POWER,</div><div class="line">.txvsel2    = CTSU_TXVSEL_MODE,</div><div class="line">.md         = CTSU_MODE_SELF_MULTI_SCAN,</div><div class="line">.posel      = CTSU_POSEL_SAME_PULSE,</div><div class="line">.ctsuchac0  = 0x0F,</div><div class="line">.ctsuchtrc0 = 0x08,</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="r_ctsu_shield.svg">r_ctsu_shield.svg</object>
<div class="caption">
Shield pin Image</div></div>
 <dl class="section note"><dt>Note</dt><dd>This feature is only available in self-capacitance mode.</dd></dl>
<h2>Temperature Correction</h2>
<p>The internal circuit of CTSU2 and r_adc can be used to compensate for temperature drift. This keeps the measured value constant even if the temperature changes. An instance for temperature correction is required to operate this function, and it is also necessary to measure this instance on a regular basis. For details, refer to the configuration and sample application output by QE for Capacitive Touch.</p>
<h2>TrustZone Support</h2>
<p>In r_ctsu and rm_touch module, Non-Secure Callable Guard Functions are only generated from QE for Capacitive Touch. QE can be used for tuning in secure or flat project, but not in non-secure project. If you want to use in non-secure project, copy the output file from secure or flat project. Refer to QE Help for more information.</p>
<h2>Diagnosis Support</h2>
<p>Diagnose the functions inside the chip. It can be implemented by adding an API function <a class="el" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a>.</p>
<h1><a class="anchor" id="r-ctsu-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the CTSU in an application.</p>
<div class="fragment"><div class="line"><span class="keyword">volatile</span> <span class="keywordtype">bool</span> g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ctsu_callback (<a class="code" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> * p_args)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group___c_t_s_u___a_p_i.html#ggaf6b0abb6cb3e6996d8435268d5e7c9cfa110041f0d6a2dcfeac8b0d2ba3d2318b">CTSU_EVENT_SCAN_COMPLETE</a> == p_args-&gt;<a class="code" href="group___c_t_s_u___a_p_i.html#a40ee54221ab1d85ee5d2ce7a5cdd289a">event</a>)</div><div class="line">    {</div><div class="line">        g_scan_flag = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ctsu_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Handle any errors. This function should be defined by the user. */</span></div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Multi-configuration Example</h2>
<p>This is a optional example of using both Self-capacitance and Mutual-capacitance configurations in the same project.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ctsu_optional_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line">    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS + (CTSU_CFG_NUM_MUTUAL_ELEMENTS * 2)];</div><div class="line"></div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl_mutual, &amp;g_ctsu_cfg_mutual);</div><div class="line">    assert(FSP_SUCCESS == err);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl_mutual);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl_mutual, data);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structctsu__ctsuwr__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a></td></tr>
<tr class="separator:structctsu__ctsuwr__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__self__buf__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a></td></tr>
<tr class="separator:structctsu__self__buf__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__mutual__buf__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__mutual__buf__t">ctsu_mutual_buf_t</a></td></tr>
<tr class="separator:structctsu__mutual__buf__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__correction__info__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__correction__info__t">ctsu_correction_info_t</a></td></tr>
<tr class="separator:structctsu__correction__info__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structctsu__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#structctsu__instance__ctrl__t">ctsu_instance_ctrl_t</a></td></tr>
<tr class="separator:structctsu__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9be3b4466784415a4193f9584362c2ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a> </td></tr>
<tr class="separator:ga9be3b4466784415a4193f9584362c2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3fb0beb148069bb590287ed34771117"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a> </td></tr>
<tr class="separator:gae3fb0beb148069bb590287ed34771117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7a98cce83446a25cc6d9fae6fa1296d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a> </td></tr>
<tr class="separator:gad7a98cce83446a25cc6d9fae6fa1296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07d91c963664201accc65a9d45fb817a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ga07d91c963664201accc65a9d45fb817a">ctsu_range_t</a> </td></tr>
<tr class="separator:ga07d91c963664201accc65a9d45fb817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structctsu__ctsuwr__t" id="structctsu__ctsuwr__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__ctsuwr__t">&#9670;&nbsp;</a></span>ctsu_ctsuwr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_ctsuwr_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>CTSUWR write register value </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="ac0528bef59c8c84d71b8f14ec06e63ef"></a>uint16_t</td>
<td class="fieldname">
ctsussc</td>
<td class="fielddoc">
Copy from (ssdiv &lt;&lt; 8) by Open API. </td></tr>
<tr><td class="fieldtype">
<a id="aaf34d3ace08918bb6475ec3d1c552ef7"></a>uint16_t</td>
<td class="fieldname">
ctsuso0</td>
<td class="fielddoc">
Copy from ((snum &lt;&lt; 10) | so) by Open API. </td></tr>
<tr><td class="fieldtype">
<a id="a7c9679ecf1fe0a5990b0876148ef95b9"></a>uint16_t</td>
<td class="fieldname">
ctsuso1</td>
<td class="fielddoc">
Copy from (sdpa &lt;&lt; 8) by Open API. ICOG and RICOA is set recommend value. </td></tr>
</table>

</div>
</div>
<a name="structctsu__self__buf__t" id="structctsu__self__buf__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__self__buf__t">&#9670;&nbsp;</a></span>ctsu_self_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_self_buf_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scan buffer data formats (Self) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6861f106e35481e78f023371e8a0a119"></a>uint16_t</td>
<td class="fieldname">
sen</td>
<td class="fielddoc">
Sensor counter data. </td></tr>
<tr><td class="fieldtype">
<a id="adc438e4276c0d59b50aed4803e7abfe7"></a>uint16_t</td>
<td class="fieldname">
ref</td>
<td class="fielddoc">
Reference counter data (Not used) </td></tr>
</table>

</div>
</div>
<a name="structctsu__mutual__buf__t" id="structctsu__mutual__buf__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__mutual__buf__t">&#9670;&nbsp;</a></span>ctsu_mutual_buf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_mutual_buf_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scan buffer data formats (Mutual) </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a8173a36e5f8828115784966f8166b688"></a>uint16_t</td>
<td class="fieldname">
pri_sen</td>
<td class="fielddoc">
Primary sensor data. </td></tr>
<tr><td class="fieldtype">
<a id="a8181f53939fa39f21dfe1bade4ecfb3d"></a>uint16_t</td>
<td class="fieldname">
pri_ref</td>
<td class="fielddoc">
Primary reference data (Not used) </td></tr>
<tr><td class="fieldtype">
<a id="a1dfbcd55fcbb9e5f84715ce6e6044ba6"></a>uint16_t</td>
<td class="fieldname">
snd_sen</td>
<td class="fielddoc">
Secondary sensor data. </td></tr>
<tr><td class="fieldtype">
<a id="af11629c8645bed6f08a9dacdbd9c6bef"></a>uint16_t</td>
<td class="fieldname">
snd_ref</td>
<td class="fielddoc">
Secondary reference data (Not used) </td></tr>
</table>

</div>
</div>
<a name="structctsu__correction__info__t" id="structctsu__correction__info__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__correction__info__t">&#9670;&nbsp;</a></span>ctsu_correction_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_correction_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Correction information </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aeea8e0424a7e537c771aa5605e234999"></a><a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a></td>
<td class="fieldname">
status</td>
<td class="fielddoc">
Correction status. </td></tr>
<tr><td class="fieldtype">
<a id="a93c9375ac0095e5fe3fcdbafb75bac27"></a><a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a></td>
<td class="fieldname">
ctsuwr</td>
<td class="fielddoc">
Correction scan parameter. </td></tr>
<tr><td class="fieldtype">
<a id="a9e6bd5681dc890925212b5e8c6992a81"></a>volatile <a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a></td>
<td class="fieldname">
scanbuf</td>
<td class="fielddoc">
Correction scan buffer. </td></tr>
<tr><td class="fieldtype">
<a id="ab57b6901038712e64335413e1410cd38"></a>uint16_t</td>
<td class="fieldname">
first_val</td>
<td class="fielddoc">
1st correction value </td></tr>
<tr><td class="fieldtype">
<a id="adf7029351b6a5a1783d9cdfdf84fc2e7"></a>uint16_t</td>
<td class="fieldname">
second_val</td>
<td class="fielddoc">
2nd correction value </td></tr>
<tr><td class="fieldtype">
<a id="acfe4f4937e286f12ce9ab99644d7c9b4"></a>uint32_t</td>
<td class="fieldname">
first_coefficient</td>
<td class="fielddoc">
1st correction coefficient </td></tr>
<tr><td class="fieldtype">
<a id="a9d61017a601220935fdd8b2802d28911"></a>uint32_t</td>
<td class="fieldname">
second_coefficient</td>
<td class="fielddoc">
2nd correction coefficient </td></tr>
<tr><td class="fieldtype">
<a id="a057c864fef470eed9c0fba106ccf7c88"></a>uint32_t</td>
<td class="fieldname">
ctsu_clock</td>
<td class="fielddoc">
CTSU clock [MHz]. </td></tr>
</table>

</div>
</div>
<a name="structctsu__instance__ctrl__t" id="structctsu__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structctsu__instance__ctrl__t">&#9670;&nbsp;</a></span>ctsu_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ctsu_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>CTSU private control block. DO NOT MODIFY. Initialization occurs when <a class="el" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682" title="Opens and configures the CTSU driver module. Implements ctsu_api_t::open. ">R_CTSU_Open()</a> is called. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="memItemLeft" align="right" valign="top"><a id="a257eb16ff64e017d0a67a0a3384fdbf7"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a257eb16ff64e017d0a67a0a3384fdbf7">open</a></td></tr>
<tr class="memdesc:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not driver is open. <br /></td></tr>
<tr class="separator:a257eb16ff64e017d0a67a0a3384fdbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16466f6ce29f3141a0413c1f30cfa8"><td class="memItemLeft" align="right" valign="top"><a id="aee16466f6ce29f3141a0413c1f30cfa8"></a>
volatile <a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aee16466f6ce29f3141a0413c1f30cfa8">state</a></td></tr>
<tr class="memdesc:aee16466f6ce29f3141a0413c1f30cfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU run state. <br /></td></tr>
<tr class="separator:aee16466f6ce29f3141a0413c1f30cfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200d61ec88212741eda11efdf320dcf2"><td class="memItemLeft" align="right" valign="top"><a id="a200d61ec88212741eda11efdf320dcf2"></a>
<a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a200d61ec88212741eda11efdf320dcf2">tuning</a></td></tr>
<tr class="memdesc:a200d61ec88212741eda11efdf320dcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Initial offset tuning status. <br /></td></tr>
<tr class="separator:a200d61ec88212741eda11efdf320dcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a41db2c42e9d1e46a7547d803b8296"><td class="memItemLeft" align="right" valign="top"><a id="a67a41db2c42e9d1e46a7547d803b8296"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a67a41db2c42e9d1e46a7547d803b8296">num_elements</a></td></tr>
<tr class="memdesc:a67a41db2c42e9d1e46a7547d803b8296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements to scan. <br /></td></tr>
<tr class="separator:a67a41db2c42e9d1e46a7547d803b8296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="memItemLeft" align="right" valign="top"><a id="a2f07e521837e8b03d7b2e3b93c9161a5"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a2f07e521837e8b03d7b2e3b93c9161a5">wr_index</a></td></tr>
<tr class="memdesc:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into ctsuwr register array. <br /></td></tr>
<tr class="separator:a2f07e521837e8b03d7b2e3b93c9161a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="memItemLeft" align="right" valign="top"><a id="ab422bfa8a5f8e1c9e56866c44c440f75"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ab422bfa8a5f8e1c9e56866c44c440f75">rd_index</a></td></tr>
<tr class="memdesc:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Word index into scan data buffer. <br /></td></tr>
<tr class="separator:ab422bfa8a5f8e1c9e56866c44c440f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f08dcec63a2aba0f31132e08667a6"><td class="memItemLeft" align="right" valign="top"><a id="a678f08dcec63a2aba0f31132e08667a6"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a678f08dcec63a2aba0f31132e08667a6">p_tuning_count</a></td></tr>
<tr class="memdesc:a678f08dcec63a2aba0f31132e08667a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to tuning count of each element. g_ctsu_tuning_count[] is set by Open API. <br /></td></tr>
<tr class="separator:a678f08dcec63a2aba0f31132e08667a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527001bce3114395980eb1ab84990d39"><td class="memItemLeft" align="right" valign="top"><a id="a527001bce3114395980eb1ab84990d39"></a>
int32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a527001bce3114395980eb1ab84990d39">p_tuning_diff</a></td></tr>
<tr class="memdesc:a527001bce3114395980eb1ab84990d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to difference from base value of each element. g_ctsu_tuning_diff[] is set by Open API. <br /></td></tr>
<tr class="separator:a527001bce3114395980eb1ab84990d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfb1f17208413aec59916e5c0d030c2"><td class="memItemLeft" align="right" valign="top"><a id="aadfb1f17208413aec59916e5c0d030c2"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aadfb1f17208413aec59916e5c0d030c2">average</a></td></tr>
<tr class="memdesc:aadfb1f17208413aec59916e5c0d030c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSU Moving average counter. <br /></td></tr>
<tr class="separator:aadfb1f17208413aec59916e5c0d030c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="memItemLeft" align="right" valign="top"><a id="aaaf1fa1d2eae6508aeb04433bd02be27"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aaaf1fa1d2eae6508aeb04433bd02be27">num_moving_average</a></td></tr>
<tr class="memdesc:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. <br /></td></tr>
<tr class="separator:aaaf1fa1d2eae6508aeb04433bd02be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83665cf5d96629fb4907ca79b605b25b"><td class="memItemLeft" align="right" valign="top"><a id="a83665cf5d96629fb4907ca79b605b25b"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a83665cf5d96629fb4907ca79b605b25b">ctsucr1</a></td></tr>
<tr class="memdesc:a83665cf5d96629fb4907ca79b605b25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from (atune1 &lt;&lt; 3, md &lt;&lt; 6) by Open API. CLK, ATUNE0, CSW, and PON is set by HAL driver. <br /></td></tr>
<tr class="separator:a83665cf5d96629fb4907ca79b605b25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="memItemLeft" align="right" valign="top"><a id="a1cf778904b1ccf46e5ce7fa6d1ec7c5f"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__ctsuwr__t">ctsu_ctsuwr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a1cf778904b1ccf46e5ce7fa6d1ec7c5f">p_ctsuwr</a></td></tr>
<tr class="memdesc:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">CTSUWR write register value. g_ctsu_ctsuwr[] is set by Open API. <br /></td></tr>
<tr class="separator:a1cf778904b1ccf46e5ce7fa6d1ec7c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="memItemLeft" align="right" valign="top"><a id="ab5911fb602e5ca9a55b2e3eb30ec3676"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__self__buf__t">ctsu_self_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ab5911fb602e5ca9a55b2e3eb30ec3676">p_self_raw</a></td></tr>
<tr class="memdesc:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self raw data. g_ctsu_self_raw[] is set by Open API. <br /></td></tr>
<tr class="separator:ab5911fb602e5ca9a55b2e3eb30ec3676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9d2ea0f565cf340e5735b1c86309fe"><td class="memItemLeft" align="right" valign="top"><a id="a7d9d2ea0f565cf340e5735b1c86309fe"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a7d9d2ea0f565cf340e5735b1c86309fe">p_self_data</a></td></tr>
<tr class="memdesc:a7d9d2ea0f565cf340e5735b1c86309fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Self moving average data. g_ctsu_self_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a7d9d2ea0f565cf340e5735b1c86309fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="memItemLeft" align="right" valign="top"><a id="a9f26ec90784dcf867d1fc63f5a0de0ff"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__mutual__buf__t">ctsu_mutual_buf_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a9f26ec90784dcf867d1fc63f5a0de0ff">p_mutual_raw</a></td></tr>
<tr class="memdesc:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual raw data. g_ctsu_mutual_raw[] is set by Open API. <br /></td></tr>
<tr class="separator:a9f26ec90784dcf867d1fc63f5a0de0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664d7b0f274da19339d9de7b4c161d1"><td class="memItemLeft" align="right" valign="top"><a id="a0664d7b0f274da19339d9de7b4c161d1"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0664d7b0f274da19339d9de7b4c161d1">p_mutual_pri_data</a></td></tr>
<tr class="memdesc:a0664d7b0f274da19339d9de7b4c161d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual primary moving average data. g_ctsu_mutual_pri_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a0664d7b0f274da19339d9de7b4c161d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621ad282765bd1f41e88b497a82e4fab"><td class="memItemLeft" align="right" valign="top"><a id="a621ad282765bd1f41e88b497a82e4fab"></a>
uint16_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a621ad282765bd1f41e88b497a82e4fab">p_mutual_snd_data</a></td></tr>
<tr class="memdesc:a621ad282765bd1f41e88b497a82e4fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to Mutual secondary moving average data. g_ctsu_mutual_snd_data[] is set by Open API. <br /></td></tr>
<tr class="separator:a621ad282765bd1f41e88b497a82e4fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291493dd7e994e95df48d4dbc2162af"><td class="memItemLeft" align="right" valign="top"><a id="ae291493dd7e994e95df48d4dbc2162af"></a>
<a class="el" href="group___c_t_s_u.html#structctsu__correction__info__t">ctsu_correction_info_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ae291493dd7e994e95df48d4dbc2162af">p_correction_info</a></td></tr>
<tr class="memdesc:ae291493dd7e994e95df48d4dbc2162af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to correction info. <br /></td></tr>
<tr class="separator:ae291493dd7e994e95df48d4dbc2162af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538262fc400f4a0095f2cd60ebb710a6"><td class="memItemLeft" align="right" valign="top"><a id="a538262fc400f4a0095f2cd60ebb710a6"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a538262fc400f4a0095f2cd60ebb710a6">p_ctsu_cfg</a></td></tr>
<tr class="memdesc:a538262fc400f4a0095f2cd60ebb710a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to initial configurations. <br /></td></tr>
<tr class="separator:a538262fc400f4a0095f2cd60ebb710a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a790f4de7d688d9a9f448a810be05f"><td class="memItemLeft" align="right" valign="top"><a id="aa4a790f4de7d688d9a9f448a810be05f"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#aa4a790f4de7d688d9a9f448a810be05f">write_irq</a></td></tr>
<tr class="memdesc:aa4a790f4de7d688d9a9f448a810be05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSUWR interrupt vector. <br /></td></tr>
<tr class="separator:aa4a790f4de7d688d9a9f448a810be05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422889992dd929096784b65c29c8780b"><td class="memItemLeft" align="right" valign="top"><a id="a422889992dd929096784b65c29c8780b"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a422889992dd929096784b65c29c8780b">read_irq</a></td></tr>
<tr class="memdesc:a422889992dd929096784b65c29c8780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSURD interrupt vector. <br /></td></tr>
<tr class="separator:a422889992dd929096784b65c29c8780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139bed35e18c276442ed790e2f49ad92"><td class="memItemLeft" align="right" valign="top"><a id="a139bed35e18c276442ed790e2f49ad92"></a>
IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a139bed35e18c276442ed790e2f49ad92">end_irq</a></td></tr>
<tr class="memdesc:a139bed35e18c276442ed790e2f49ad92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy from config by Open API. CTSU_CTSUFN interrupt vector. <br /></td></tr>
<tr class="separator:a139bed35e18c276442ed790e2f49ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c65e56730176fb25ab76ddb33b772ee"><td class="memItemLeft" align="right" valign="top"><a id="a0c65e56730176fb25ab76ddb33b772ee"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a0c65e56730176fb25ab76ddb33b772ee">p_callback</a> )(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *)</td></tr>
<tr class="memdesc:a0c65e56730176fb25ab76ddb33b772ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback provided when a CTSUFN occurs. <br /></td></tr>
<tr class="separator:a0c65e56730176fb25ab76ddb33b772ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="memItemLeft" align="right" valign="top"><a id="a042150cc9f3c41639dcd6bb989e6ba1e"></a>
<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#a042150cc9f3c41639dcd6bb989e6ba1e">p_callback_memory</a></td></tr>
<tr class="memdesc:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to non-secure memory that can be used to pass arguments to a callback in non-secure memory. <br /></td></tr>
<tr class="separator:a042150cc9f3c41639dcd6bb989e6ba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3493d9a66a667f943638459c3ba5392"><td class="memItemLeft" align="right" valign="top"><a id="ac3493d9a66a667f943638459c3ba5392"></a>
void const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_t_s_u.html#ac3493d9a66a667f943638459c3ba5392">p_context</a></td></tr>
<tr class="memdesc:ac3493d9a66a667f943638459c3ba5392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for user data. <br /></td></tr>
<tr class="separator:ac3493d9a66a667f943638459c3ba5392"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9be3b4466784415a4193f9584362c2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be3b4466784415a4193f9584362c2ce">&#9670;&nbsp;</a></span>ctsu_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#ga9be3b4466784415a4193f9584362c2ce">ctsu_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU run state </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2cea728f7cac2f957376ddfdcb0a9bc7eb24"></a>CTSU_STATE_INIT&#160;</td><td class="fielddoc"><p>Not open. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2cead492927de253bafe181a3430d1ed6759"></a>CTSU_STATE_IDLE&#160;</td><td class="fielddoc"><p>Opened. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2ceaf35310abebbd7594def0fd113abc9009"></a>CTSU_STATE_SCANNING&#160;</td><td class="fielddoc"><p>Scanning now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9be3b4466784415a4193f9584362c2ceaf5bf0b9c2914f02bc13287aaf25193a7"></a>CTSU_STATE_SCANNED&#160;</td><td class="fielddoc"><p>Scan end. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae3fb0beb148069bb590287ed34771117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3fb0beb148069bb590287ed34771117">&#9670;&nbsp;</a></span>ctsu_tuning_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#gae3fb0beb148069bb590287ed34771117">ctsu_tuning_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU Initial offset tuning status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae3fb0beb148069bb590287ed34771117ac5b463f4f8d75c188535febbb8f3265b"></a>CTSU_TUNING_INCOMPLETE&#160;</td><td class="fielddoc"><p>Initial offset tuning incomplete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae3fb0beb148069bb590287ed34771117ac3e474244bf3dfaeaf0d6f418d87cadd"></a>CTSU_TUNING_COMPLETE&#160;</td><td class="fielddoc"><p>Initial offset tuning complete. </p>
</td></tr>
</table>

</div>
</div>
<a id="gad7a98cce83446a25cc6d9fae6fa1296d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7a98cce83446a25cc6d9fae6fa1296d">&#9670;&nbsp;</a></span>ctsu_correction_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#gad7a98cce83446a25cc6d9fae6fa1296d">ctsu_correction_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU Correction status </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da544177e8ae7de2375f436f67d8f0fe85"></a>CTSU_CORRECTION_INIT&#160;</td><td class="fielddoc"><p>Correction initial status. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da226216e141c9645a7b026e71552fff8b"></a>CTSU_CORRECTION_RUN&#160;</td><td class="fielddoc"><p>Correction scan running. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da547ad26a74b30f6abc040e88ca531b1d"></a>CTSU_CORRECTION_COMPLETE&#160;</td><td class="fielddoc"><p>Correction complete. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggad7a98cce83446a25cc6d9fae6fa1296da9ca74c2bfb3ebcc87035a6c9eec1b12f"></a>CTSU_CORRECTION_ERROR&#160;</td><td class="fielddoc"><p>Correction error. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga07d91c963664201accc65a9d45fb817a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07d91c963664201accc65a9d45fb817a">&#9670;&nbsp;</a></span>ctsu_range_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_t_s_u.html#ga07d91c963664201accc65a9d45fb817a">ctsu_range_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CTSU range definition </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa18e0227acbd85f4a0e698e66e10ff399"></a>CTSU_RANGE_20UA&#160;</td><td class="fielddoc"><p>20uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa8f4c9333b63b727e17dbe5cb1bba2b5d"></a>CTSU_RANGE_40UA&#160;</td><td class="fielddoc"><p>40uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aabe7fe0af42bd5680a187198d0a940b65"></a>CTSU_RANGE_80UA&#160;</td><td class="fielddoc"><p>80uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa245c0b1c0e2c81523be95944d61438ea"></a>CTSU_RANGE_160UA&#160;</td><td class="fielddoc"><p>160uA mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga07d91c963664201accc65a9d45fb817aa7c1c26d795d57571c5b9441ea18f626d"></a>CTSU_RANGE_NUM&#160;</td><td class="fielddoc"><p>number of range </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga4e625d8c9f3b301a46913c5827732682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e625d8c9f3b301a46913c5827732682">&#9670;&nbsp;</a></span>R_CTSU_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__cfg__t">ctsu_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens and configures the CTSU driver module. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#ae8f2c7b3cc9e33f0f790f76655d3d723">ctsu_api_t::open</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    err = <a class="code" href="group___c_t_s_u.html#ga4e625d8c9f3b301a46913c5827732682">R_CTSU_Open</a>(&amp;g_ctsu_ctrl, &amp;g_ctsu_cfg);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer, or one or more configuration options is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>Module is already open. This module can only be opened once. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_ARGUMENT</td><td>Configuration parameter error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In the first Open, measurement for correction works, and it takes several tens of milliseconds. </dd></dl>

</div>
</div>
<a id="ga46cf185922bbca921cb92b4c18f62525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46cf185922bbca921cb92b4c18f62525">&#9670;&nbsp;</a></span>R_CTSU_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called each time a periodic timer expires. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Before starting the next scan, first get the data with <a class="el" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe" title="This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled...">R_CTSU_DataGet()</a>. If a different control block scan should be run, check the scan is complete before executing. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a1df87278ab5d47fdd093994f53de96a6">ctsu_api_t::scanStart</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance or other. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_NOT_GET_DATA</td><td>The previous data has not been retrieved by DataGet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cff42feeaa3d73216b73c313fb9a5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cff42feeaa3d73216b73c313fb9a5fe">&#9670;&nbsp;</a></span>R_CTSU_DataGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_DataGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor values as scanned by the CTSU. If initial offset tuning is enabled, The first several calls are used to tuning for the sensors. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aadcc6930b4e9d0ad86b6f607e86c28f5">ctsu_api_t::dataGet</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga46cf185922bbca921cb92b4c18f62525">R_CTSU_ScanStart</a>(&amp;g_ctsu_ctrl);</div><div class="line">        assert(FSP_SUCCESS == err);</div><div class="line">        <span class="keywordflow">while</span> (!g_scan_flag)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Wait for scan end callback */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        g_scan_flag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        err = <a class="code" href="group___c_t_s_u.html#ga1cff42feeaa3d73216b73c313fb9a5fe">R_CTSU_DataGet</a>(&amp;g_ctsu_ctrl, data);</div><div class="line">        <span class="keywordflow">if</span> (FSP_SUCCESS == err)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Application specific data processing. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_SCANNING</td><td>Scanning this instance. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_INCOMPLETE_TUNING</td><td>Incomplete initial offset tuning. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_NOT_YET</td><td>Diagnosis of data collected no yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c966546f3774ce2228739a5ffc0ac19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c966546f3774ce2228739a5ffc0ac19">&#9670;&nbsp;</a></span>R_CTSU_CallbackSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_CallbackSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_api_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *)&#160;</td>
          <td class="paramname"><em>p_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *const&#160;</td>
          <td class="paramname"><em>p_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#structctsu__callback__args__t">ctsu_callback_args_t</a> *const&#160;</td>
          <td class="paramname"><em>p_callback_memory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the user callback and has option of providing memory for callback structure. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#adda480537f35733dbed856a30b89be50">ctsu_api_t::callbackSet</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Callback updated successfully. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>A required pointer is NULL. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>The control block has not been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_NO_CALLBACK_MEMORY</td><td>p_callback is non-secure and p_callback_memory is either secure or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45103e8db4a16dfabf3a516ab2da9f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45103e8db4a16dfabf3a516ab2da9f26">&#9670;&nbsp;</a></span>R_CTSU_Diagnosis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Diagnosis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Diagnosis the CTSU peripheral. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#a42a81fef42f2bf61bde59cba4796cc0e">ctsu_api_t::diagnosis</a>. </p>
<p>Example: </p><div class="fragment"><div class="line">            err = <a class="code" href="group___c_t_s_u.html#ga45103e8db4a16dfabf3a516ab2da9f26">R_CTSU_Diagnosis</a>(&amp;g_ctsu_ctrl_diagnosis);</div><div class="line">            assert(FSP_SUCCESS == err);</div><div class="line"></div></div><!-- fragment --> <dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_NOT_GET_DATA</td><td>The previous data has not been retrieved by DataGet. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_LDO_OVER_VOLTAGE</td><td>Diagnosis of LDO over voltage failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CCO_HIGH</td><td>Diagnosis of CCO into 19.2uA failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CCO_LOW</td><td>Diagnosis of CCO into 2.4uA failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SSCG</td><td>Diagnosis of SSCG frequency failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_DAC</td><td>Diagnosis of non-touch count value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OUTPUT_VOLTAGE</td><td>Diagnosis of LDO output voltage failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OVER_VOLTAGE</td><td>Diagnosis of over voltage detection circuit failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_OVER_CURRENT</td><td>Diagnosis of over current detection circuit failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_LOAD_RESISTANCE</td><td>Diagnosis of LDO internal resistance value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CURRENT_SOURCE</td><td>Diagnosis of LDO internal resistance value failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SENSCLK_GAIN</td><td>Diagnosis of SENSCLK frequency gain failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_SUCLK_GAIN</td><td>Diagnosis of SUCLK frequency gain failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CLOCK_RECOVERY</td><td>Diagnosis of SUCLK clock recovery function failed. </td></tr>
    <tr><td class="paramname">FSP_ERR_CTSU_DIAG_CFC_GAIN</td><td>Diagnosis of CFC oscillator gain failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73b45020c568d57065c8a7adecaaeb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b45020c568d57065c8a7adecaaeb4c">&#9670;&nbsp;</a></span>R_CTSU_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_CTSU_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_t_s_u___a_p_i.html#gad2634158ab8191a774e7b99eacee5a98">ctsu_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables specified CTSU control block. Implements <a class="el" href="group___c_t_s_u___a_p_i.html#aeb44bb4a59bad9025f0897cee306a395">ctsu_api_t::close</a>. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>CTSU successfully configured. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>Null pointer passed as a parameter. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Module is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP Release v3.1.0 User's Manual Copyright © (2021) Renesas Electronics Corporation. All Rights Reserved.</li>
  </ul>
</div>
</body>
</html>
