<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>RA Flexible Software Package Documentation: Analog to Digital Converter (r_adc)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="fsp_customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_scaled.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">RA Flexible Software Package Documentation
   &#160;<span id="projectnumber">Release v0.8.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_d_c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a>  </div>
  <div class="headertitle">
<div class="title">Analog to Digital Converter (r_adc)<div class="ingroups"><a class="el" href="group___r_e_n_e_s_a_s___m_o_d_u_l_e_s.html">Modules</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gade895e0810cecb3be6a9e5217f5c78ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const p_cfg)</td></tr>
<tr class="separator:gade895e0810cecb3be6a9e5217f5c78ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ced4152033e944b1bd4b9bd35634c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga6ced4152033e944b1bd4b9bd35634c18">R_ADC_ScanCfg</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__channel__cfg__t">adc_channel_cfg_t</a> const *const p_channel_cfg)</td></tr>
<tr class="separator:ga6ced4152033e944b1bd4b9bd35634c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">R_ADC_InfoGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *p_adc_info)</td></tr>
<tr class="separator:ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a7fb2265b5a03c7586253ff28b3faf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga4a7fb2265b5a03c7586253ff28b3faf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b5242c153c6320a564ed9ffd324f144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga9b5242c153c6320a564ed9ffd324f144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga676b1c7f1ccceda288cbb2ad79a14ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *p_status)</td></tr>
<tr class="separator:ga676b1c7f1ccceda288cbb2ad79a14ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6bfc8395b53a96ee89f266fc940e2da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint16_t *const p_data)</td></tr>
<tr class="separator:gad6bfc8395b53a96ee89f266fc940e2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga905e1cd6ff8ca4aaf91ee63529dc0d0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga905e1cd6ff8ca4aaf91ee63529dc0d0d">R_ADC_Read32</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, uint32_t *const p_data)</td></tr>
<tr class="separator:ga905e1cd6ff8ca4aaf91ee63529dc0d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0701bf45818dee071cb12e979017bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#structadc__sample__state__t">adc_sample_state_t</a> *p_sample)</td></tr>
<tr class="separator:gaf0701bf45818dee071cb12e979017bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga499187b3067534e42a57239ead111797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga499187b3067534e42a57239ead111797">R_ADC_Close</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *p_ctrl)</td></tr>
<tr class="separator:ga499187b3067534e42a57239ead111797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3bc65f19ba61612e0b7517dfd41ab61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gaf3bc65f19ba61612e0b7517dfd41ab61">R_ADC_OffsetSet</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, <a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const reg_id, int32_t offset)</td></tr>
<tr class="separator:gaf3bc65f19ba61612e0b7517dfd41ab61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2e4cd66d5bd276d05eb5fa104a2037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#gafb2e4cd66d5bd276d05eb5fa104a2037">R_ADC_Calibrate</a> (<a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const p_ctrl, void *const p_extend)</td></tr>
<tr class="separator:gafb2e4cd66d5bd276d05eb5fa104a2037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ef435c2d9a890729e770e6d25c790e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#ga5ef435c2d9a890729e770e6d25c790e1">R_ADC_VersionGet</a> (<a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const p_version)</td></tr>
<tr class="separator:ga5ef435c2d9a890729e770e6d25c790e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Driver for the ADC12, ADC14, and ADC16 peripherals on RA MCUs. This module implements the <a class="el" href="group___a_d_c___a_p_i.html">ADC Interface</a>. </p>
<h1><a class="anchor" id="r-adc-overview"></a>
Overview</h1>
<h2><a class="anchor" id="r-adc-features"></a>
Features</h2>
<p>The ADC module supports the following features:</p>
<ul>
<li>12, 14, or 16 bit maximum resolution depending on the MCU</li>
<li>Configure scans to include:<ul>
<li>Multiple analog channels</li>
<li>Temperature sensor channel<a class="anchor" id="um_adc_support_the_on_chip_temperature_sensor"></a></li>
<li>Voltage sensor channel<a class="anchor" id="um_adc_support_the_on_chip_voltage_sensor"></a></li>
</ul>
</li>
<li>Configurable scan start trigger:<ul>
<li>Software scan triggers<a class="anchor" id="um_adc_starting_a_conversion"></a></li>
<li>Hardware scan triggers (timer expiration, for example)</li>
<li>External scan triggers from the ADTRGn port pins</li>
</ul>
</li>
<li>Configurable scan mode:<ul>
<li>Single scan mode, where each trigger starts a single scan</li>
<li>Continuous scan mode, where all channels are scanned continuously</li>
<li>Group scan mode, where channels are grouped into group A and group B. The groups can be assigned different start triggers, and group A can be given priority over group B. When group A has priority over group B, a group A trigger suspends an ongoing group B scan.</li>
</ul>
</li>
<li>Supports adding and averaging converted samples</li>
<li>Optional callback when scan completes<a class="anchor" id="um_adc_interrupt_callback_data"></a><a class="anchor" id="um_adc_support_for_group_mode_scan_completion_interrupts"></a></li>
<li>Supports reading converted data<a class="anchor" id="um_adc_reading_conversion_data"></a></li>
<li>Sample and hold support</li>
</ul>
<h1><a class="anchor" id="r-adc-configuration"></a>
Configuration</h1>
<p><a class="anchor" id="um_adc_configure_conversion_data_resolution"></a><a class="anchor" id="um_adc_configure_conversion_data_alignment"></a><a class="anchor" id="um_adc_automatically_clearing_conversion_results"></a><a class="anchor" id="um_adc_hardware_support_for_automatically_adding_converted_data"></a><a class="anchor" id="um_adc_hardware_support_for_automatically_averaging_sampled_data"></a><a class="anchor" id="um_adc_configure_single_scan_mode"></a><a class="anchor" id="um_adc_configure_software_trigger"></a><a class="anchor" id="um_adc_configure_the_hardware_trigger"></a><a class="anchor" id="um_adc_configure_continuous_mode"></a><a class="anchor" id="um_adc_configure_channels_for_group_mode"></a><a class="anchor" id="um_adc_configure_group_scan_mode"></a><a class="anchor" id="um_adc_configuring_sample_and_hold"></a> <h2>Build Time Configurations for r_adc</h2>
The following build time configurations are defined in fsp_cfg/r_adc_cfg.h:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Description </th></tr>
<tr>
<td>Parameter Checking</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
BSP</li>
<li>
Enabled</li>
<li>
Disabled</li>
</ul>
</td><td>If selected code for parameter checking is included in the build. </td></tr>
</table>
 <h2>Configurations for ADC Driver on r_adc</h2>
This module can be added to the Threads tab from New -&gt; Driver -&gt; Analog -&gt; ADC Driver on r_adc:<br />
</p><table class="doxtable">
<tr>
<th>Configuration</th><th>Options</th><th>Description </th></tr>
<tr>
<td>General|Name</td><td>Name must be a valid C symbol</td><td>Module name </td></tr>
<tr>
<td>General|Unit</td><td>Unit must be a non-negative integer</td><td>Specifies the ADC Unit to be used. </td></tr>
<tr>
<td>General|Resolution</td><td>MCU Specific Options</td><td>Specifies the conversion resolution for this unit. </td></tr>
<tr>
<td>General|Alignment</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Right</li>
<li>
Left</li>
</ul>
</td><td>Specifies the conversion result alignment. </td></tr>
<tr>
<td>General|Clear after read</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Off</li>
<li>
On</li>
</ul>
</td><td>Specifies if the result register will be automatically cleared after the conversion result is read. </td></tr>
<tr>
<td>General|Mode</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Single Scan</li>
<li>
Continuous Scan</li>
<li>
Group Scan</li>
</ul>
</td><td>Specifies the mode that this ADC unit is used in. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 0</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 1</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 2</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 3</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 4</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 5</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 6</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 7</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 8</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 9</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 10</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 11</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 12</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 13</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 14</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 15</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 16</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 17</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 18</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 19</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 20</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 21</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 22</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 23</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 24</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 25</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 26</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Channel 27</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Temperature Sensor</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Input|Channel Scan Mask (channel availability varies by MCU)|Voltage Sensor</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Unused</li>
<li>
Use in Normal/Group A</li>
<li>
Use in Group B</li>
</ul>
</td><td>In Normal mode of operation, this bitmask field specifies the channels that are enabled in that ADC unit. In group mode, this field specifies which channels belong to group A. </td></tr>
<tr>
<td>Interrupts|Normal/Group A Trigger</td><td>MCU Specific Options</td><td>Specifies the trigger type to be used for this unit.  </td></tr>
<tr>
<td>Interrupts|Group B Trigger (Valid only in Group Scan Mode)</td><td>MCU Specific Options</td><td></td></tr>
<tr>
<td>Interrupts|Group Priority (Valid only in Group Scan Mode)</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Group A cannot interrupt Group B</li>
<li>
Group A can interrupt Group B; Group B scan restarts at next trigger</li>
<li>
Group A can interrupt Group B; Group B scan restarts immediately</li>
<li>
Group A can interrupt Group B; Group B scan restarts immediately and scans continuously</li>
</ul>
</td><td>Determines whether an ongoing group B scan can be interrupted by a group A trigger, whether it should abort on a group A trigger, or if it should pause to allow group A scan and restart immediately after group A scan is complete. </td></tr>
<tr>
<td>Input|Add/Average Count</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Add two samples</li>
<li>
Add three samples</li>
<li>
Add four samples</li>
<li>
Add sixteen samples</li>
<li>
Average two samples</li>
<li>
Average four samples</li>
</ul>
</td><td>Specifies if addition or averaging needs to be done for any of the channels in this unit. </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 0</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 1</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 2</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 3</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 4</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 5</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 6</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 7</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 8</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 9</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 10</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 11</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 12</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 13</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 14</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 15</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 16</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 17</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 18</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 19</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 20</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 21</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 22</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 23</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 24</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 25</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 26</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Channel 27</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Temperature Sensor</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Addition/Averaging Mask (channel availability varies by MCU)|Voltage Sensor</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Addition/Averaging Mask </td></tr>
<tr>
<td>Input|Sample and Hold|Sample and Hold Mask (Available only on selected MCUs)|Channel 0</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Sample and Hold Mask. </td></tr>
<tr>
<td>Input|Sample and Hold|Sample and Hold Mask (Available only on selected MCUs)|Channel 1</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Sample and Hold Mask. </td></tr>
<tr>
<td>Input|Sample and Hold|Sample and Hold Mask (Available only on selected MCUs)|Channel 2</td><td><ul style="margin-top:0;margin-bottom:0;">
<li>
Disabled</li>
<li>
Enabled</li>
</ul>
</td><td>Specifies if this channel is included in the Sample and Hold Mask. </td></tr>
<tr>
<td>Input|Sample and Hold|Sample Hold States (Applies only to the 3 channels selected above)</td><td>Value must be a non-negative integer</td><td>Specifies the updated sample-and-hold count for the channel dedicated sample-and-hold circuit </td></tr>
<tr>
<td>Interrupts|Callback</td><td>Name must be a valid C symbol</td><td>A user callback function. If this callback function is provided, it is called from the interrupt service routine (ISR) each time the ADC scan completes. </td></tr>
<tr>
<td>Interrupts|Scan End Interrupt Priority</td><td>MCU Specific Options</td><td>Select scan end interrupt priority. </td></tr>
<tr>
<td>Interrupts|Scan End Group B Interrupt Priority</td><td>MCU Specific Options</td><td>Select group B scan end interrupt priority. </td></tr>
</table>
</p>
<h2><a class="anchor" id="r-adc-clock-configuration"></a>
Clock Configuration</h2>
<p>The ADC clock is PCLKC if the MCU has PCLKC, or PCLKD otherwise.</p>
<p>The ADC clock must be at least 1 MHz when the ADC is used. Many MCUs also have PCLK ratio restrictions when the ADC is used. For details on PCLK ratio restrictions, reference the footnotes in the second table of the Clock Generation Circuit chapter of the MCU User's Manual (for example, Table 9.2 "Specifications
of the clock generation circuit for the internal clocks" in the RA6M3 manual R01UH0886EJ0100).</p>
<h2><a class="anchor" id="r-adc-pin-configuration"></a>
Pin Configuration</h2>
<p>The ANxxx pins are analog input channels that can be used with the ADC.</p>
<p><a class="anchor" id="um_adc_configure_the_external_trigger"></a>ADTRG0 and ADTRG1 can be used to start scans with an external trigger for unit 0 and 1 respectively. When external triggers are used, ADC scans begin on the falling edge of the ADTRG pin.</p>
<h1><a class="anchor" id="r-adc-usage_notes"></a>
Usage Notes</h1>
<h2>Sample Hold</h2>
<p>Enabling the sample and hold functionality reduces the maximum scan frequency because the sample and hold time is added to each scan. Refer to the hardware manual for details on the sample and hold time.</p>
<h2><a class="anchor" id="adc-hal-module-operational-overview"></a>
ADC Operational Modes</h2>
<p>The driver supports three operation modes: single-scan, continuous-scan, and group-scan modes. In each mode, analog channels are converted in ascending order of channel number, followed by scans of the temperature sensor and voltage sensor if they are included in the mask of channels to scan.</p>
<h3>Single-scan Mode</h3>
<p>In single scan mode, one or more specified channels are scanned once per trigger.</p>
<h3>Continuous-scan Mode</h3>
<p>In continuous scan mode, a single trigger is required to start the scan. Scans continue until <a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop()</a> is called.</p>
<h3>Group-scan Mode</h3>
<p>Group-scan mode allows the application to allocate channels to one of two groups (A and B). Conversion begins when the specified ELC start trigger for that group is received.</p>
<p>With the priority configuration parameter, you can optionally give group A priority over group B. If group A has priority over group B, a group B scan is interrupted when a group A scan trigger occurs. The following options exist for group B when group A has priority:</p>
<ul>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_restart"></a>To restart the interrupted group B scan after the group A scan completes.</li>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_wait"></a>To wait for another group B trigger and forget the interrupted scan.</li>
<li><a class="anchor" id="um_adc_configure_group_mode_priority_continuous"></a>To continuously scan group B and suspend scanning group B only when a group A trigger is received. <dl class="section note"><dt>Note</dt><dd>If this option is selected, group B scanning begins immediately after <a class="el" href="group___a_d_c.html#ga6ced4152033e944b1bd4b9bd35634c18">R_ADC_ScanCfg()</a>. Group A scan triggers must be enabled by <a class="el" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart()</a> and can be disabled by <a class="el" href="group___a_d_c.html#ga9b5242c153c6320a564ed9ffd324f144">R_ADC_ScanStop()</a>. Group B scans can only be disabled by reconfiguring the group A priority to a different mode.</dd></dl>
<h3>When Interrupts Are Not Enabled</h3>
</li>
</ul>
<p>If interrupts are not enabled, the R_ADC_StatusGet API can be used to poll the ADC to determine when the scan has completed. The read API function is used to access the converted ADC result. This applies to both normal scans and calibration scans for MCUs that support calibration.</p>
<h2>Sample-State Count Setting</h2>
<p>The application program can modify the setting of the sample-state count for analog channels by calling the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function. The application program only needs to modify the sample-state count settings from their default values to increase the sampling time. This can be either because the impedance of the input signal is too high to secure sufficient sampling time under the default setting or if the ADCLK is too slow. To modify the sample-state count for a given channel, set the channel number and the number of states when calling the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function. Valid sample state counts are 7-255.</p>
<dl class="section note"><dt>Note</dt><dd>Although the hardware supports a minimum number of sample states of 5, some MCUs require 7 states, so the minimum is set to 7. At the lowest supported ADC conversion clock rate (1 MHz), these extra states will lead to, at worst case, a 2 microsecond increase in conversion time. At 60 MHz the extra states will add 33.4 ns to the conversion time.</dd></dl>
<p>If the sample state count needs to be changed for multiple channels, the application program must call the <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a> API function repeatedly, with appropriately modified arguments for each channel.</p>
<p>If the ADCLK frequency changes, the sample states may need to be updated.</p>
<h3>Sample States for Temperature Sensor and Internal Voltage Reference</h3>
<p>Sample states for the temperature sensor and the internal reference voltage are calculated during <a class="el" href="group___a_d_c.html#ga6ced4152033e944b1bd4b9bd35634c18">R_ADC_ScanCfg()</a> based on the ADCLK frequency at the time. The sample states for the temperature sensor and internal voltage reference cannot be updated with <a class="el" href="group___a_d_c.html#gaf0701bf45818dee071cb12e979017bce">R_ADC_SampleStateCountSet()</a>. If the ADCLK frequency changes, call <a class="el" href="group___a_d_c.html#ga6ced4152033e944b1bd4b9bd35634c18">R_ADC_ScanCfg()</a> before using the temperature sensor or internal reference voltage again to ensure the sampling time for the temperature sensor and internal voltage reference is optimal.</p>
<h2>Using the Temperature Sensor with the ADC</h2>
<p>The ADC HAL module supports reading the data from the on-chip temperature sensor. The value returned from the sensor can be converted into degrees Celsius or Fahrenheit in the application program using the following formula, T = (Vs - V1)/slope + T1, where:</p>
<ul>
<li>T: Measured temperature (degrees C)</li>
<li>Vs: Voltage output by the temperature sensor at the time of temperature measurement (Volts)</li>
<li>T1: Temperature experimentally measured at one point (degrees C)</li>
<li>V1: Voltage output by the temperature sensor at the time of measurement of T1 (Volts)</li>
<li>T2: Temperature at the experimental measurement of another point (degrees C)</li>
<li>V2: Voltage output by the temperature sensor at the time of measurement of T2 (Volts)</li>
<li>Slope: Temperature gradient of the temperature sensor (V/degrees C); slope = (V2 - V1)/ (T2 - T1)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The slope value can be obtained from the hardware manual for each device in the Electrical Characteristics Chapter - TSN Characteristics Table, Temperature slope entry.</dd></dl>
<h2>Usage Notes for ADC16</h2>
<h3>Calibration</h3>
<p>Calibration is required to use the ADC16 peripheral. When using this driver on an MCU that has ADC16, call <a class="el" href="group___a_d_c.html#gafb2e4cd66d5bd276d05eb5fa104a2037">R_ADC_Calibrate()</a> after open, and prior to any other function.</p>
<h3>Range of ADC16 Results</h3>
<p>The range of the ADC16 is from 0 (lowest) to 0x7FFF (highest) when used in single-ended mode. This driver only supports single ended mode.</p>
<h1><a class="anchor" id="r-adc-examples"></a>
Examples</h1>
<h2>Basic Example</h2>
<p>This is a basic example of minimal use of the ADC in an application.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keywordtype">void</span> adc_basic_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Enable channels. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga6ced4152033e944b1bd4b9bd35634c18">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t channel1_conversion_result;</div><div class="line">    <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814a203b48944d019f4fda969a6fc2a9e492">ADC_CHANNEL_1</a>, &amp;channel1_conversion_result);</div><div class="line"></div><div class="line">}</div><div class="line"></div></div><!-- fragment --> <h2>Temperature Sensor Example</h2>
<p>This example shows how to calculate the MCU temperature using the ADC and the temperature sensor.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_CALIBRATION_DATA_RA6M3                (0x7D5)</span></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_VCC_MICROVOLT                        (3300000)</span></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_TEMPERATURE_RESOLUTION               (12U)</span></div><div class="line"><span class="preprocessor">#define ADC_EXAMPLE_REFERENCE_CALIBRATION_TEMPERATURE    (127)</span></div><div class="line"><span class="keywordtype">void</span> adc_temperature_example (<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* The following example calculates the temperature on an RA6M1 device using the data provided in the section</span></div><div class="line"><span class="comment">     * 44.3.1 &quot;Preparation for Using the Temperature Sensor&quot; of the RA6M1 manual R01UH0884EJ0100. */</span></div><div class="line"></div><div class="line">    <a class="code" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> err = FSP_SUCCESS;</div><div class="line"></div><div class="line">    <span class="comment">/* Initializes the module. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#gade895e0810cecb3be6a9e5217f5c78ac">R_ADC_Open</a>(&amp;g_adc0_ctrl, &amp;g_adc0_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable temperature sensor. */</span></div><div class="line">    err = <a class="code" href="group___a_d_c.html#ga6ced4152033e944b1bd4b9bd35634c18">R_ADC_ScanCfg</a>(&amp;g_adc0_ctrl, &amp;g_adc0_channel_cfg);</div><div class="line">    handle_error(err);</div><div class="line"></div><div class="line">    <span class="comment">/* In software trigger mode, start a scan by calling R_ADC_ScanStart(). In other modes, enable external</span></div><div class="line"><span class="comment">     * triggers by calling R_ADC_ScanStart(). */</span></div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga4a7fb2265b5a03c7586253ff28b3faf2">R_ADC_ScanStart</a>(&amp;g_adc0_ctrl);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for conversion to complete. */</span></div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> status;</div><div class="line">    status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a> = <a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a>;</div><div class="line">    <span class="keywordflow">while</span> (<a class="code" href="group___a_d_c___a_p_i.html#gga2783ab2e29809bf0a50bc66c6fa8d3c6abe1c11b191e48669cc5129aca45800d7">ADC_STATE_SCAN_IN_PROGRESS</a> == status.<a class="code" href="group___a_d_c___a_p_i.html#a276869569116678c7838ef506fceb77b">state</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___a_d_c.html#ga676b1c7f1ccceda288cbb2ad79a14ff2">R_ADC_StatusGet</a>(&amp;g_adc0_ctrl, &amp;status);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read converted data. */</span></div><div class="line">    uint16_t temperature_conversion_result;</div><div class="line">    (void) <a class="code" href="group___a_d_c.html#gad6bfc8395b53a96ee89f266fc940e2da">R_ADC_Read</a>(&amp;g_adc0_ctrl, <a class="code" href="group___a_d_c___a_p_i.html#ggaafc4060027875f8fe46242b0656d7814aff4cf0b5a9bfd1fc634f6b097e34fe73">ADC_CHANNEL_TEMPERATURE</a>, &amp;temperature_conversion_result);</div><div class="line"></div><div class="line"><span class="preprocessor">#if BSP_FEATURE_ADC_TSN_CALIBRATION_AVAILABLE</span></div><div class="line"></div><div class="line">    <span class="comment">/* Get Calibration data from the MCU. */</span></div><div class="line">    int32_t    reference_calibration_data;</div><div class="line">    <a class="code" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> adc_info;</div><div class="line">    (void) <a class="code" href="group___a_d_c.html#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">R_ADC_InfoGet</a>(&amp;g_adc0_ctrl, &amp;adc_info);</div><div class="line">    reference_calibration_data = (int32_t) adc_info.<a class="code" href="group___a_d_c___a_p_i.html#a5869042d58165926402aa499eefb68f2">calibration_data</a>;</div><div class="line">#<span class="keywordflow">else</span></div><div class="line"></div><div class="line">    <span class="comment">/* If the MCU does not provide calibration data, use the value in the hardware manual or determine it</span></div><div class="line"><span class="comment">     * experimentally. */</span></div><div class="line">    int32_t reference_calibration_data = ADC_EXAMPLE_CALIBRATION_DATA_RA6M3;</div><div class="line">#endif</div><div class="line"></div><div class="line">    <span class="comment">/* NOTE: The slope of the temperature sensor varies from sensor to sensor. Renesas recommends calculating</span></div><div class="line"><span class="comment">     * the slope of the temperature sensor experimentally.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * This example uses the typical slope provided in Table 52.38  &quot;TSN characteristics&quot; in the RA6M1 manual</span></div><div class="line"><span class="comment">     * R01UM0011EU0050. */</span></div><div class="line">    int32_t slope_uv_per_c = BSP_FEATURE_ADC_TSN_SLOPE;</div><div class="line"></div><div class="line">    <span class="comment">/* Formula for calculating temperature copied from section 44.3.1 &quot;Preparation for Using the Temperature Sensor&quot;</span></div><div class="line"><span class="comment">     * of the RA6M1 manual R01UH0884EJ0100:</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * In this MCU, the TSCDR register stores the temperature value (CAL127) of the temperature sensor measured</span></div><div class="line"><span class="comment">     * under the condition Ta = Tj = 127 C and AVCC0 = 3.3 V. By using this value as the sample measurement result</span></div><div class="line"><span class="comment">     * at the first point, preparation before using the temperature sensor can be omitted.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * If V1 is calculated from CAL127,</span></div><div class="line"><span class="comment">     * V1 = 3.3 * CAL127 / 4096 [V]</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * Using this, the measured temperature can be calculated according to the following formula.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * T = (Vs - V1) / Slope + 127 [C]</span></div><div class="line"><span class="comment">     * T: Measured temperature (C)</span></div><div class="line"><span class="comment">     * Vs: Voltage output by the temperature sensor when the temperature is measured (V)</span></div><div class="line"><span class="comment">     * V1: Voltage output by the temperature sensor when Ta = Tj = 127 C and AVCC0 = 3.3 V (V)</span></div><div class="line"><span class="comment">     * Slope: Temperature slope given in Table 52.38 / 1000 (V/C)</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    int32_t v1_uv = (ADC_EXAMPLE_VCC_MICROVOLT &gt;&gt; ADC_EXAMPLE_TEMPERATURE_RESOLUTION) *</div><div class="line">                    reference_calibration_data;</div><div class="line">    int32_t vs_uv = (ADC_EXAMPLE_VCC_MICROVOLT &gt;&gt; ADC_EXAMPLE_TEMPERATURE_RESOLUTION) *</div><div class="line">                    temperature_conversion_result;</div><div class="line">    int32_t temperature_c = (vs_uv - v1_uv) / slope_uv_per_c + ADC_EXAMPLE_REFERENCE_CALIBRATION_TEMPERATURE;</div><div class="line"></div><div class="line">    <span class="comment">/* Expect room temperature, break if temperature is outside the range of 20 C to 25 C. */</span></div><div class="line">    <span class="keywordflow">if</span> ((temperature_c &lt; 20) || (temperature_c &gt; 25))</div><div class="line">    {</div><div class="line">        __BKPT(0);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structadc__instance__ctrl__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_d_c.html#structadc__instance__ctrl__t">adc_instance_ctrl_t</a></td></tr>
<tr class="separator:structadc__instance__ctrl__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structadc__instance__ctrl__t" id="structadc__instance__ctrl__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structadc__instance__ctrl__t">&#9670;&nbsp;</a></span>adc_instance_ctrl_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct adc_instance_ctrl_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>ADC instance control block. DO NOT INITIALIZE. Initialized in <a class="el" href="group___a_d_c___a_p_i.html#afa184c06541e3fd9f90fc12ed775f468">adc_api_t::open()</a>. </p>
</div>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gade895e0810cecb3be6a9e5217f5c78ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade895e0810cecb3be6a9e5217f5c78ac">&#9670;&nbsp;</a></span>R_ADC_Open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__cfg__t">adc_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the operational mode, trigger sources, interrupt priority, and configurations for the peripheral as a whole. If interrupt is enabled, the function registers a callback function pointer for notifying the user whenever a scan has completed.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module is ready for use. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_ALREADY_OPEN</td><td>The instance control structure has already been opened. </td></tr>
    <tr><td class="paramname">FSP_ERR_IRQ_BSP_DISABLED</td><td>A callback is provided, but the interrupt is not enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_IP_CHANNEL_NOT_PRESENT</td><td>The requested unit does not exist on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>The ADC clock must be at least 1 MHz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ced4152033e944b1bd4b9bd35634c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ced4152033e944b1bd4b9bd35634c18">&#9670;&nbsp;</a></span>R_ADC_ScanCfg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__channel__cfg__t">adc_channel_cfg_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_channel_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the ADC scan parameters. Channel specific settings are set in this function.</p>
<dl class="section note"><dt>Note</dt><dd>This starts group B scans if <a class="el" href="group___a_d_c___a_p_i.html#aef59542e008313144646bd057d840c8a" title="Valid for group modes. ">adc_channel_cfg_t::priority_group_a</a> is set to ADC_GROUP_A_GROUP_B_CONTINUOUS_SCAN.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Channel specific settings applied. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cc44d84e1dd1cad8fdafe1e91a3b6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc44d84e1dd1cad8fdafe1e91a3b6d0">&#9670;&nbsp;</a></span>R_ADC_InfoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_InfoGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__info__t">adc_info_t</a> *&#160;</td>
          <td class="paramname"><em>p_adc_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the address of the lowest number configured channel and the total number of bytes to be read in order to read the results of the configured channels and return the ELC Event name. If no channels are configured, then a length of 0 is returned.</p>
<p>Also provides the temperature sensor slope and the calibration data for the sensor if available on this MCU. Otherwise, invalid calibration data of 0xFFFFFFFF will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>In group mode, information is returned for group A only. Calculating information for group B is not currently supported.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Information stored in p_adc_info. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a7fb2265b5a03c7586253ff28b3faf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a7fb2265b5a03c7586253ff28b3faf2">&#9670;&nbsp;</a></span>R_ADC_ScanStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a software scan or enables the hardware trigger for a scan depending on how the triggers were configured in the R_ADC_Open call. If the unit was configured for ELC or external hardware triggering, then this function allows the trigger signal to get to the ADC unit. The function is not able to control the generation of the trigger itself. If the unit was configured for software triggering, then this function starts the software triggered scan.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Call R_ADC_ScanCfg after R_ADC_Open before starting a scan.</dd>
<dd>
On MCUs that support calibration, call R_ADC_Calibrate and wait for calibration to complete before starting a scan.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan started (software trigger) or hardware triggers enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
    <tr><td class="paramname">FSP_ERR_IN_USE</td><td>Another scan is still in progress (software trigger). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b5242c153c6320a564ed9ffd324f144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b5242c153c6320a564ed9ffd324f144">&#9670;&nbsp;</a></span>R_ADC_ScanStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_ScanStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the software scan or disables the unit from being triggered by the hardware trigger (ELC or external) based on what type of trigger the unit was configured for in the R_ADC_Open function. Stopping a hardware triggered scan via this function does not abort an ongoing scan, but prevents the next scan from occurring. Stopping a software triggered scan aborts an ongoing scan.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Scan stopped (software trigger) or hardware triggers disabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga676b1c7f1ccceda288cbb2ad79a14ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga676b1c7f1ccceda288cbb2ad79a14ff2">&#9670;&nbsp;</a></span>R_ADC_StatusGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_StatusGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__status__t">adc_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides the status of any scan process that was started, including scans started by ELC or external triggers and calibration scans on MCUs that support calibration.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module status stored in the provided pointer p_status </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6bfc8395b53a96ee89f266fc940e2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6bfc8395b53a96ee89f266fc940e2da">&#9670;&nbsp;</a></span>R_ADC_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga905e1cd6ff8ca4aaf91ee63529dc0d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga905e1cd6ff8ca4aaf91ee63529dc0d0d">&#9670;&nbsp;</a></span>R_ADC_Read32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Read32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads conversion results from a single channel or sensor register into a 32-bit result.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Data read into provided p_data. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf0701bf45818dee071cb12e979017bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0701bf45818dee071cb12e979017bce">&#9670;&nbsp;</a></span>R_ADC_SampleStateCountSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_SampleStateCountSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#structadc__sample__state__t">adc_sample_state_t</a> *&#160;</td>
          <td class="paramname"><em>p_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sample state count for individual channels. This only needs to be set for special use cases. Normally, use the default values out of reset.</p>
<dl class="section note"><dt>Note</dt><dd>The sample states for the temperature and voltage sensor are set in R_ADC_ScanCfg.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Sample state count updated. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga499187b3067534e42a57239ead111797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga499187b3067534e42a57239ead111797">&#9670;&nbsp;</a></span>R_ADC_Close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *&#160;</td>
          <td class="paramname"><em>p_ctrl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function ends any scan in progress, disables interrupts, and removes power to the A/D peripheral.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Module closed. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3bc65f19ba61612e0b7517dfd41ab61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3bc65f19ba61612e0b7517dfd41ab61">&#9670;&nbsp;</a></span>R_ADC_OffsetSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_OffsetSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaafc4060027875f8fe46242b0656d7814">adc_channel_t</a> const&#160;</td>
          <td class="paramname"><em>reg_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="group___a_d_c___a_p_i.html#a305b2c2466cd88fdddf6134db542dc7e">adc_api_t::offsetSet</a> is not supported on the ADC.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Function not supported in this implementation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb2e4cd66d5bd276d05eb5fa104a2037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2e4cd66d5bd276d05eb5fa104a2037">&#9670;&nbsp;</a></span>R_ADC_Calibrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_Calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_d_c___a_p_i.html#gaff9488cd90102a90e5c5cbd45394d426">adc_ctrl_t</a> *const&#160;</td>
          <td class="paramname"><em>p_ctrl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>p_extend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates calibration of the ADC on MCUs that require calibration. This function must be called before starting a scan on MCUs that require calibration.</p>
<p>Calibration is complete when the callback is called with ADC_EVENT_CALIBRATION_COMPLETE or when R_ADC_StatusGet returns ADC_STATUS_IDLE. Reference Figure 32.35 "Software flow and operation example of calibration operation." in the RA2A1 manual R01UH0888EJ0100.</p>
<p>ADC calibration time: 12 PCLKB + 774,930 ADCLK. (Reference Table 32.16 "Required calibration time (shown
as the number of ADCLK and PCLKB cycles)" in the RA2A1 manual R01UH0888EJ0100. The lowest supported ADCLK is 1MHz.</p>
<p>Calibration will take a minimum of 24 milliseconds at 32 MHz PCLKB and ADCLK. This wait could take up to 780 milliseconds for a 1 MHz PCLKD (ADCLK).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_ctrl</td><td>Pointer to the instance control structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_extend</td><td>Unused argument. Pass NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Calibration successfully initiated. </td></tr>
    <tr><td class="paramname">FSP_ERR_INVALID_HW_CONDITION</td><td>A scan is in progress or hardware triggers are enabled. </td></tr>
    <tr><td class="paramname">FSP_ERR_UNSUPPORTED</td><td>Calibration not supported on this MCU. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
    <tr><td class="paramname">FSP_ERR_NOT_OPEN</td><td>Unit is not open. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ef435c2d9a890729e770e6d25c790e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ef435c2d9a890729e770e6d25c790e1">&#9670;&nbsp;</a></span>R_ADC_VersionGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#gadfb1288da0fcc7ae1dc88c58601374f8">fsp_err_t</a> R_ADC_VersionGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___r_e_n_e_s_a_s___e_r_r_o_r___c_o_d_e_s.html#unionfsp__version__t">fsp_version_t</a> *const&#160;</td>
          <td class="paramname"><em>p_version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the API version number.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FSP_SUCCESS</td><td>Version stored in the provided p_version. </td></tr>
    <tr><td class="paramname">FSP_ERR_ASSERTION</td><td>An input argument is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
        <li class="footer">FSP v0.8.0 User's Manual Rev0.80 R11UM0137EU0080 Copyright © (2019) Renesas Electronics Corporation. All Rights Reserved.</li>
    <li class="footer">Generated by FSP v0.8.0
    </li>
  </ul>
</div>
</body>
</html>
